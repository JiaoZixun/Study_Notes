# 每日一题

1）[[1893. 检查是否区域内所有整数都被覆盖](https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/)——简单]

```c++
//方法一，打表，若区间内在表中未出现则返回false
//方法二，差分数组，左端点为1，因为左闭右闭右端点+1的位置为-1表示区间结束，前缀和检查目标区间内的和是否大于0，大于0说明该区间存在，否则表示区间不存在返回false。
class Solution {
public:
    bool isCovered(vector<vector<int>>& ranges, int left, int right) {
        vector<int>diff(52);//差分数组
        //左端点++，（右端点+1）--
        for(auto &it:ranges){
            ++diff[it[0]];//左端点位置+1
            --diff[it[1]+1];//右端点右边-1
            
            //在此区间内都存在
        }
        //前缀和
        int cur=0;
        for(int i=1;i<=50;i++){
            //从左开始cur为正数则表示区间存在，到结尾-1变为0
            cur+=diff[i];
            //当前位置在目标区间内，但是此区间不存在
            if(i>=left&&i<=right&&cur<=0)   return false;
        }
        return true;
        
    }
};
```

2）[[1743. 从相邻元素对还原数组](https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/)——中等]（方法一，map，第一个相邻元素只有一个的为首，根据首的相邻元素存入第二个，继续找第三个，若第三个的相邻元素0在前两位出现过则选择相邻元素1。）

```c++
class Solution {
public:
    vector<int> restoreArray(vector<vector<int>>& adjacentPairs) {
        map<int,vector<int>>mp;
        for(auto &nums:adjacentPairs){
            mp[nums[0]].push_back(nums[1]);
            mp[nums[1]].push_back(nums[0]);
        }
        int n=adjacentPairs.size()+1;
        vector<int>ans(n);
        for(auto &[idx,adj]:mp){
            if(adj.size()==1){
                ans[0]=idx;//开头
                break;
            }
        }
        ans[1]=mp[ans[0]][0];//第二个
        //除了首尾每一位相邻只有两个，0位若在当前位的前两位出现过则存1位
        for(int i=2;i<n;i++){
            auto &nums=mp[ans[i-1]];//与第i-1位相连的其他数
            //当前的0位是否和前两位相同
            ans[i]=ans[i-2]==nums[0]?nums[1]:nums[0];
        }
        return ans;
    }
};
```

3）[[1713. 得到子序列的最少操作次数](https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence/)——困难]（方法一，找最大公共子序列——>找最大递增子序列）

```c++
class Solution {
public:
    int minOperations(vector<int>& target, vector<int>& arr) {
        //找到最长公共子序列，n-最长公共子序列得到答案
        //最长公共子序列，target互不相同，使用哈希表将target数组对应的值的下标存上
        //将arr数组的值对应的target值的下标存入数组
        //转换为寻找new_target和new_arr数组最大公共子序列，new_target为递增，找new_arr中
        //最长递增序列为最大公共子序列
        int n=arr.size(),m=target.size();
        unordered_map<int,int>new_target;
        vector<int>new_arr;
        for(int i=0;i<m;i++){
            new_target[target[i]]=i;
        }
        for(int i=0;i<n;i++){
            if(new_target.find(arr[i])!=new_target.end()){
                new_arr.push_back(new_target[arr[i]]);
            }
        }
        //for(int i=0;i<new_arr.size();i++)   cout<<new_arr[i]<<" ";
        if(new_arr.size()==0)   return m;
        //在new_arr中找到最大升序序列
        vector<int>d(new_arr.size()+1);
        int len=1;
        d[len]=new_arr[0];
        for(int i=1;i<new_arr.size();i++){
            if(new_arr[i]>d[len]){
                d[++len]=new_arr[i];
            }
            else{
                int l=1,r=len,pos=0;
                while(l<=r){
                    int mid=(l+r)>>1;
                    if(d[mid]<new_arr[i]){
                        pos=mid;
                        l=mid+1;
                    }
                    else    r=mid-1;
                }
                d[pos+1]=new_arr[i];
            }
        }
        return m-len;
    }
};
```

找最大公共子序列：

```c++
//动态规划：
//dp[i][j]表示两个字符串从0-i和从0-j的最长公共子序列
//若第i、j个字母相同，dp[i][j]=dp[i-1][j-1]+1
//若不同，dp[i][j]=max(dp[i-1][j],dp[i][j-1])，为第一个字符串0-i-1和第二个字符串0-j的公共子序列和
//第一个字符串0-i和第二个字符串0-j-1的公共子序列之间最大值
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m=text1.length(),n=text2.length();
        vector<vector<int>>dp(m+1,vector<int>(n+1));
        for(int i=1;i<=m;i++){
            char ch1=text1.at(i-1);
            for(int j=1;j<=n;j++){
                char ch2=text2.at(j-1);
                if(ch1==ch2)    dp[i][j]=dp[i-1][j-1]+1;
                else{
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[m][n];
    }
};
```

找递增最大子序列：

```c++
//维护一个d数组，存入递增升序序列，贪心策略认为后续加入的数字递增的更慢，后续加入的满足递增的数字尽可能小
//d[0]存入nums第一个数
//若后续数字大于d数组的最后一个，则将其存入
//若后续数字小于等于d数组的最后一个，找出d数组中最后一个小于该数的位置，在+1位替换
//d：1  3  6  8    存入：4
//d：1  3  4  8
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n=nums.size(),len=1;
        vector<int>d(n+1);
        d[len]=nums[0];
        for(int i=1;i<n;i++){
            if(nums[i]>d[len]){
                d[++len]=nums[i];//存在一个比d数组末尾大的加入d数组，组成升序序列
            }  
            else{
                int l=1,r=len,pos=0;
                while(l<=r){//找到d数组中最后一个小于nums[i]的位置
                    int mid=(l+r)>>1;
                    if(d[mid]<nums[i]){
                        pos=mid;
                        l=mid+1;
                    }
                    else{
                        r=mid-1;
                    }
                }
                d[pos+1]=nums[i];
            }
        }
        return len;
    }
};
```

4）[[863. 二叉树中所有距离为 K 的结点](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/)——中等]（方法一，第一遍深度优先搜索找到每个结点的父节点利用map存储，然后第二遍深度优先搜索从target结点出发，先向下搜索然后延父节点向上搜索，为了防止和当前结点重复传入from结点表示当前结点遍历的前一个结点。）

```c++
class Solution {
public:
    vector<int>ans;
    unordered_map<int,TreeNode*>parents;
    void findparent(TreeNode* t){
        if(t->left){
            parents[t->left->val]=t;
            findparent(t->left);
        }
        if(t->right){
            parents[t->right->val]=t;
            findparent(t->right);
        }
    }
    void dfs(TreeNode* t,TreeNode* from,int depth,int k){
        if(!t)  return ;
        if(depth==k){
            ans.push_back(t->val);
            return ;
        }
        if(t->left!=from){//递归父节点时，防止遍历到左右相同元素
            dfs(t->left,t,depth+1,k);//递归左
        }
        if(t->right!=from){
            dfs(t->right,t,depth+1,k);//递归右
        }
        if(parents[t->val]!=from){//递归左右子树时，防止回到根
            dfs(parents[t->val],t,depth+1,k);//递归父节点
        }
    }
    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {
        findparent(root);//找到每个节点的父节点
        dfs(target,NULL,0,k);//从target出发
        return ans;
    }
};
```

5）[[1104. 二叉树寻路](https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/)——中等]（方法一，数学，偶数层的左右结点之和等于从左向右两侧结点之和，奇数层等于子节点/2。）

```c++
vector<int> pathInZigZagTree(int label) {
	int h=get2(label);//得到层数
	vector<int>ans;
	if(h%2==0){//初始为偶数层，从新计算label
		label=getlabel(label,h);
	}
	while(h>0){
		if(h%2==0){//偶数时，当前层左右结点序号与从左到右结点序号相同，左右结点和-label也相同
			ans.push_back(getlabel(label,h));//左右两侧结点之和减去label
		}
		else{//奇数时，编号从左到右，可以由子节点除以2得到
			ans.push_back(label);
		}
		h--;
		label>>=1;//每次除以2，返回上一层从左到右结点序号
	}
	reverse(ans.begin(),ans.end());
	return ans;
}
```

6）[[5833. 统计特殊子序列的数目](https://leetcode-cn.com/problems/count-number-of-special-subsequences/)——困难]（方法一，状态转移，第i位出现0的时候可以0放在[0-i-1]中，也可以作为新起点。）

```c++
class Solution {
public:
    int mod=1e9 + 7;
    int countSpecialSubsequences(vector<int>& nums) {
        long long a=0,b=0,c=0;
        for(auto &num:nums){
            if(num==0)  a=(2*a+1)%mod;
            if(num==1)  b=(2*b%mod+a)%mod;
            if(num==2)  c=(2*c%mod+b)%mod;
        }
        return (int)c;
    }
};
```

7）[[743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)——中等]（方法一，Dijkstra算法，单源最短路径。）

```c++
class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        //单源最短路径
        const int inf=INT_MAX/2;//最大值

        //建图
        vector<vector<int>>tu(n,vector<int>(n,inf));
        for(auto &it:times){
            int x=it[0]-1,y=it[1]-1;
            tu[x][y]=it[2];
        }
        
        //Dijkstra算法
        vector<int>dist(n,inf);//起点到各点的距离
        dist[k-1]=0;//起点
        vector<int>used(n);//未确定点
        for(int i=0;i<n;i++){
            int x=-1;
            for(int y=0;y<n;y++){//找到未确定点中最短边
                if(!used[y]&&(x==-1||dist[y]<dist[x])){
                    x=y;
                }
            }
            used[x]=true;//已确定点为true
            //松弛
            for(int y=0;y<n;y++){
                dist[y]=min(dist[y],dist[x]+tu[x][y]);//取 起点到y的距离 和 起点到x的距离+x到y的距离 的最小值
            }
        }
        int ans=*max_element(dist.begin(),dist.end());
        return ans==inf?-1:ans;
    }
};
```

8）[[581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)——中等]（方法一，排序后比较。方法二，一次遍历，找到非递增数组的最大最小位置。）

```c++
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        //[2,6,4,8,10,9,15]
        int n=nums.size(),maxn=INT_MIN,minn=INT_MAX,left=-1,right=-1;
        for(int i=0;i<n;i++){
            if(maxn>nums[i]){
                right=i;
            }else{
                maxn=nums[i];
            }
            if(minn<nums[n-i-1]){
                left=n-i-1;
            }else{
                minn=nums[n-i-1];
            }
        }
        return right==-1?0:right-left+1;
    }
};
```

9）[[611. 有效三角形的个数](https://leetcode-cn.com/problems/valid-triangle-number/)——中等]（方法一，排序+二分，三角形需要满足a+b>c,a+c>b,b+c>a三个条件，数组排序后只需满足a+b>c即可，两重for循环+二分查找最后一个小于a+b的位置，该位置到b之间都是满足a+b>c的。）

```c++
class Solution {
public:
    int cnt;
    bool pan(int a,int b,int c){
        if((a+c>b)&&(a+b>c)&&(b+c>a))    return true;
        return false;
    }
    int triangleNumber(vector<int>& nums) {
        int n=nums.size();
        cnt=0;
        sort(nums.begin(),nums.end());
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                int l=j+1,r=n-1,k=j;
                while(l<=r){
                    int mid=(l+r)/2;
                    if(nums[mid]<nums[i]+nums[j]){//找到[j+1,n-1]区间内最后一个小于nums[i]+nums[j]的位置
                        k=mid;
                        l=mid+1;
                    }
                    else    r=mid-1;
                }
                cnt+=k-j;
            }
        }
        return cnt;
    }
};
```

10）[[802. 找到最终的安全状态](https://leetcode-cn.com/problems/find-eventual-safe-states/)——中等]（方法一，拓扑排序，建反图将入度为0的结点入队，将目标节点入度-1，为0时入队，最后所有入度为0的结点为安全结点。）

```c++
//若一个节点没有出边，则该节点是安全的；若一个节点出边相连的点都是安全的，则该节点也是安全的。
//故建反图后拓扑排序，将入度为0的结点入队，找到相邻结点入度-1，最后所有入度为0的结点为安全结点
class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        //拓扑排序
        //建反图
        int n=graph.size();
        vector<vector<int>>rg(n);
        vector<int>ru(n);
        for(int i=0;i<n;i++){
            for(int &j:graph[i]){
                rg[j].push_back(i);
            }
            ru[i]=graph[i].size();
        }
        //队列存入度为0的点
        queue<int>que;
        for(int i=0;i<n;i++){
            if(ru[i]==0)    que.push(i);
        }
        while(!que.empty()){
            int y=que.front();
            que.pop();
            for(auto &i:rg[y]){
                if(--ru[i]==0)    que.push(i);
            }
        }
        vector<int>ans;
        for(int i=0;i<n;i++){
            if(ru[i]==0)    ans.push_back(i);
        }
        return ans;
    }
};
```

11）[[847. 访问所有节点的最短路径](https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/)——困难]（方法一，三元组表示：当前结点u、经过结点二进制标记、路径长，每个结点的三元组存入队列，依次出队，找到u的相邻结点改变二进制标记，若全部访问完成返回长度。）

```c++
class Solution {
public:
    int shortestPathLength(vector<vector<int>>& graph) {
        int n=graph.size();
        queue<tuple<int,int,int>>que;//三元组：当前结点、经过结点标记、路径长度
        vector<vector<int>>seen(n,vector<int>(1 << n));//标记走过结点
        for(int i=0;i<n;i++){
            que.emplace(i,1<<i,0);//以每个结点为起点开始
            seen[i][1<<i]=true;//将二进制中的1左移i位表示第i位存在
        }
        int ans=0;
        while(!que.empty()){
            auto [u,flag,dist]=que.front();
            que.pop();
            if(flag==(1<<n)-1){//全部遍历完成
                ans=dist;
                break;
            }
            for(auto v:graph[u]){//找到相邻结点
                //将 flag 的第 v 位置为 1
                int flag_v=flag | (1<<v);//在二进制位中标记走过结点为1，或操作：有1则为1
                if(!seen[v][flag_v]){//没有走过
                    que.emplace(v,flag_v,dist+1);
                    seen[v][flag_v]=true;
                }
            }
        }
        return ans;
    }
};
```

12）[[457. 环形数组是否存在循环](https://leetcode-cn.com/problems/circular-array-loop/)——中等]（方法一，快慢指针，low从当前结点出发，fast每次移动两步，相遇时有环，注意循环为1的情况需要跳过，每次将走过的变为0。）

```c++
class Solution {
public:
    bool circularArrayLoop(vector<int>& nums) {
        int n=nums.size();
        auto next=[&](int i){//内联函数
            return (i+nums[i]%n+n)%n;//保证返回值在[0,n)
        };
        for(int i=0;i<n;i++){
            if(!nums[i])    continue;//走过的跳过
            int low=i,fast=next(i);//快慢指针
            //当前非零，方向相同
            while(nums[low]*nums[fast]>0&&nums[low]*nums[next(fast)]>0){
                if(low==fast){
                    //循环为1的情况
                    if(low!=next(low))  return true;
                    else    break;
                }
                low=next(low);
                fast=next(next(fast));
            }
            //走过的变为0
            int add=i;
            while(nums[add]*nums[next(add)]>0){
                int t=add;
                add=next(add);//找到下一步
                nums[t]=0;//当前归0
            }
        }
        return false;
    }
};
```

13）[[313. 超级丑数](https://leetcode-cn.com/problems/super-ugly-number/)——中等]（方法一，最小堆，堆顶元素*primes数组中每个元素，第n次得到答案。）

```c++
class Solution {
public:
    int nthSuperUglyNumber(int n, vector<int>& primes) {
        //最小堆
        unordered_set<long>st;//去重
        priority_queue<long,vector<long>,greater<long>>min_dui;//最小堆
        st.insert(1);
        min_dui.push(1);
        int ans=0;
        for(int i=0;i<n;i++){
            ans=min_dui.top();//第n次堆顶元素为答案
            min_dui.pop();
            for(auto num:primes){
                long t=(long)ans*num;//乘法可能超过int型范围
                if(st.insert(t).second){
                    min_dui.push(t);
                }
            }
        }
        return ans;
    }
};
```

14）[[413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)——中等]（方法一，动态规划，以i结尾的等差数列有t个，差值d变换后t重新计数。）

```c++
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int n=nums.size();
        if(n==1)    return 0;
        int d=nums[0]-nums[1],t=0,ans=0;
        //等差数列至少为3，下标从2开始
        for(int i=2;i<n;i++){
            if(nums[i-1]-nums[i]==d){//以i结尾的等差数列有t个
                t++;
            }
            else{//更换差值d，t重新计数
                d=nums[i-1]-nums[i];
                t=0;
            }
            ans+=t;
        }
        return ans;
    }
};
```

15）[[446. 等差数列划分 II - 子序列](https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/)——困难]（方法一，动态规划，dp id 表示以nums[i]为结尾公差为d的数量。）

```c++
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int n=nums.size(),ans=0;
        if(n<3)    return 0;
        //动态规划，定义dp[i][d]为尾项为nums[i]，公差为d的数量
        //dp[j][d]+=dp[i][d]
        vector<unordered_map<long long,int>>dp(n);//map存差值:数量
        for(int i=0;i<n;i++){
            for(int j=0;j<i;j++){
                long long d=(long long)nums[i]-nums[j];
                auto it=dp[j].find(d);//在以j为结尾的哈希中找d，若找到说明存入当前位满足最少为3的子序列
                int cnt=it==dp[j].end()?0:it->second;//在哈希中找到公差为d的数量
                ans+=cnt;//每次加上满足条件的数量
                dp[i][d]+=cnt+1;
            }
        }
        return ans;
    }
};
```

16）[[516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)——中等]（方法一，动态规划，dp[i][j]表示从i到j的回文串长度。）

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n=s.size();
        vector<vector<int>>dp(n,vector<int>(n));//表示从i到j的回文串长度
        for(int i=n-1;i>=0;i--){//行倒序
            dp[i][i]=1;
            char c1=s[i];
            for(int j=i+1;j<n;j++){
                char c2=s[j];
                if(c1==c2){
                    dp[i][j]=dp[i+1][j-1]+2;//在前一个回文串首尾加上c1 c2
                }
                else{
                    dp[i][j]=max(dp[i+1][j],dp[i][j-1]);//去掉首或尾最长的回文串
                }
            }
        }
        return dp[0][n-1];
    }
};
```

17）[[233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/)——困难]（方法一，按位计数，假设为4位，想象为密码锁，从个位开始将其固定为1，其余3位随意转动，共有三种情况，1.当前位为0，共有高位 * 位数种情况；2.当前位为1，共有高位 * 位数+低位+1种情况；3.当前位为其他数，共有（高位+1）*位数种情况。）

```c++
class Solution {
public:
    int countDigitOne(int n) {
        long long dight=1;
        int hight=n/10,cur=n%10,low=0,ans=0;
        while(hight!=0||cur!=0){
            if(cur==0){//1.当前位数字为0时，包含1的情况有，高位*位数
                ans+=hight*dight;
            }
            else if(cur==1){//2.当前位数字为1时，包含1的情况有，高位*位数+低位+1
                ans+=hight*dight+low+1;
            }
            else{//3.当前位数字为2-9时，包含1的情况有，（高位+1）*位数
                ans+=(hight+1)*dight;
            }
            low+=cur*dight;//保持低位
            cur=hight%10;//取下一位
            hight/=10;//高位
            dight*=10;//位数进一
        }
        return ans;
    }
};
```

18）[[576. 出界的路径数](https://leetcode-cn.com/problems/out-of-boundary-paths/)——中等]（方法一，三层动态规划，走i步到达jk位置的路线数。）

```c++
class Solution {
public:
    const long long mod=1e9+7;
    int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        int outcount=0;
        vector<vector<int>>dist={{-1,0},{1,0},{0,-1},{0,1}};//上下左右
        vector<vector<vector<int>>>dp(maxMove+1,vector<vector<int>>(m,vector<int>(n)));//dp[i][j][k]表示移动i次到达jk点的路径数
        dp[0][startRow][startColumn]=1;//起点
        for(int i=0;i<maxMove;i++){
            for(int j=0;j<m;j++){
                for(int k=0;k<n;k++){
                    int count=dp[i][j][k];
                    if(count>0){
                        for(auto it:dist){
                            int h=j+it[0],l=k+it[1];
                            if(h>=0&&h<m&&l>=0&&l<n){
                                dp[i+1][h][l]=(dp[i+1][h][l]+count)%mod;
                            }
                            else    outcount=(count+outcount)%mod;
                        }
                    }
                }
            }
        }
        return outcount;
    }
};
```

19）[[526. 优美的排列](https://leetcode-cn.com/problems/beautiful-arrangement/)——中等]（方法一，回溯+标记数组，初始化一个二维数组存入每一位可以放的数。）

```c++
class Solution {
public:
    int ans=0;
    vector<bool>vis;
    void dfs(vector<vector<int>> &match,int idx){
        if(idx==match.size()){
            ans++;
            return ;
        }
        for(auto &x:match[idx]){//取出第idx行可能放的数
            if(!vis[x]){//利用标记数组，标记某一数字使用过
                vis[x]=true;
                dfs(match,idx+1);
                vis[x]=false;//回溯
            }
        }
    }
    int countArrangement(int n) {
        vector<vector<int>>match(n+1);
        vis.resize(n+1);
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if((j%i==0)||(i%j==0)){
                    match[i].push_back(j);//初始化二维数组，存入每位可以放的数
                }
            }
        }
        dfs(match,1);//回溯递归
        return ans;
    }
};
```

20）[[552. 学生出勤记录 II](https://leetcode-cn.com/problems/student-attendance-record-ii/)——困难]（方法一，动态规划，三维数组表示第i天有j次缺勤k次迟到，共有6种状态，最后统计第n天1次缺勤和2次迟到之内的所有值的和。）

```c++
class Solution {
public:
    const long long mod=1e9+7;
    int checkRecord(int n) {
        //三维数组表示第i天有j次缺勤k次迟到
        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(2,vector<int>(3)));
        dp[0][0][0]=1;
        for(int i=1;i<=n;i++){
            //1.dp[i][0][0]：今天截止0次缺席，今天截止0连续迟到。
            dp[i][0][0]=(dp[i][0][0]%mod+dp[i-1][0][0]%mod+dp[i-1][0][1]%mod+dp[i-1][0][2]%mod)%mod;//今天截止0次缺席，今天截止0次连续迟到：过去一定也是0次缺席，但过去可以有0，1，2次连续迟到，因为只要我今天按时出席，过去的迟到记录都一笔勾销。
            //2.dp[i][0][1]：今天截止0次缺席，今天截止1连续迟到。
            dp[i][0][1]=(dp[i][0][1]+dp[i-1][0][0])%mod;//加上前一天0次缺席0次迟到的数量
            //3.dp[i][0][2]：今天截止0次缺席，今天截止2连续迟到。
            dp[i][0][2]=(dp[i][0][2]+dp[i-1][0][1])%mod;//加上前一天0次缺席1次迟到的数量
            //4.dp[i][1][0]：今天截止1次缺席，今天截止0连续迟到。
            dp[i][1][0]=((dp[i][1][0])%mod+(dp[i-1][1][0])%mod+(dp[i-1][1][1])%mod+(dp[i-1][1][2])%mod+(dp[i-1][0][0])%mod+(dp[i-1][0][1])%mod+(dp[i-1][0][2])%mod)%mod;//加上前一天1次缺席的012次迟到数量和0次缺席的012次迟到数量
            //5.dp[i][1][1]：今天截止1次缺席，今天截止1连续迟到。
            dp[i][1][1]=(dp[i][1][1]+dp[i-1][1][0])%mod;
            //6.dp[i][1][2]：今天截止1次缺席，今天截止2连续迟到。
            dp[i][1][2]=(dp[i][1][2]+dp[i-1][1][1])%mod;
        }
        int sum=0;
        for(int j=0;j<=1;j++){
            for(int k=0;k<=2;k++){
                sum=(dp[n][j][k]+sum)%mod;
            }
        }
        return sum;
    }
};
```

21）[[789. 逃脱阻碍者](https://leetcode-cn.com/problems/escape-the-ghosts/)——中等]（方法一，计算曼哈顿距离，若玩家比幽灵更快到终点则肯定能过，若幽灵比玩家快则肯定被拦截。）

```c++
class Solution {
public:
    int dist(vector<int> a,vector<int> b){//计算曼哈顿距离
        return abs(a[0]-b[0])+abs(a[1]-b[1]);
    }
    bool escapeGhosts(vector<vector<int>>& ghosts, vector<int>& target) {
        int flag=dist({0,0},{target[0],target[1]});
        for(auto &it:ghosts){
            int zu=dist({it[0],it[1]},{target[0],target[1]});
            if(zu<=flag)    return false;//若幽灵比玩家距离终点近则肯定会被拦截
        }
        return true;//若幽灵更远则玩家更先到终点，不会中途被拦截
    }
};
```

22）[[787. K 站中转内最便宜的航班](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)——中等]（方法一，动态规划，dp存中转k次从起点到终点的最小花费。）

```c++
class Solution {
public:
    const int max_flag=10000 * 101 + 1;
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        vector<vector<int>>dp(k+2,vector<int>(n,max_flag));//中转k次从起点到达终点的最小花费
        dp[0][src]=0;//中转0次到达起点的花费
        for(int t=1;t<=k+1;t++){//中转t次
            for(auto f:flights){
                int st=f[0],end=f[1],cost=f[2];//起点、终点、花费
                dp[t][end]=min(dp[t-1][st]+cost,dp[t][end]);//少中转一次到当前起点的花费+当前航班花费和当前中转次数的花费取最小值
            }
        }
        int ans=max_flag;
        for(int t=1;t<=k+1;t++){
            ans=min(ans,dp[t][dst]);
        }
        return ans==max_flag?-1:ans;
    }
};
```

23）[[797. 所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)——中等]（方法一，DFS，从0开始依次遍历到达n-1的所有路径，因为是有向图可以不用标记走过的结点，每个结点只遍历一次。）

```c++
class Solution {
public:
    vector<vector<int>>ans;
    vector<int>linshi;
    void dfs(vector<vector<int>>& graph,int cur){
        if(cur==graph.size()-1){
            linshi.push_back(cur);
            ans.push_back(linshi);
            return;
        }
        linshi.push_back(cur);
        for(int j=0;j<graph[cur].size();j++){
            dfs(graph,graph[cur][j]);
            linshi.pop_back();
        }
    }
    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {
        dfs(graph,0);
        return ans;
    }
};
```

24）[[881. 救生艇](https://leetcode-cn.com/problems/boats-to-save-people/)——中等]（方法一，贪心，排序后每次取最大最小，若和大于限制本次运最大，否则运最大最小。）

```c++
class Solution {
public:
    int numRescueBoats(vector<int>& people, int limit) {
        sort(people.rbegin(),people.rend());//从大到小
        int n=people.size();
        int l=0,r=n-1,ans=0;
        while(l<r){
            if(people[l]+people[r]>limit){
                ans++;
                l++;
            }
            else{
                ans++;
                l++;
                r--;
            }
        }
        if(l==r)    ans++;
        return ans;
    }
};
```

25）[[295. 数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)——困难]（方法一，两个优先队列，以第一个数为基准，大的数放到大根堆，小的数放到小根堆，若为奇数小根堆堆顶为中位数，为偶数大根堆堆顶为两堆堆顶和/2。）

```c++
class MedianFinder {
public:
    /** initialize your data structure here. */
    priority_queue<int,vector<int>,less<int>>min_que;//大根堆
    priority_queue<int,vector<int>,greater<int>>max_que;//小根堆
    MedianFinder() {}
    void addNum(int num) {
        //以第一个数为基准，大于的进入小根堆max，小的进入大根堆min
        if(min_que.empty()||num<=min_que.top()){//第一个数先加入大根堆min
            min_que.push(num);
            if(min_que.size()>max_que.size()+1){//如果大根堆数量大于小根堆两个，将大根堆堆顶加入小根堆，然后弹出大根堆堆顶
                max_que.push(min_que.top());
                min_que.pop();
            }
        }
        else{
            max_que.push(num);
            if(max_que.size()>min_que.size()){//加入一个大数时
                min_que.push(max_que.top());//将小根堆中最小的移动到大根堆
                max_que.pop();
            }
        }
    }
    double findMedian() {
        if(min_que.size()>max_que.size()){//奇数时
            return min_que.top();
        }
        return  (min_que.top()+max_que.top())/2.0;//偶数时
    }
};
```

26）[[528. 按权重随机选择](https://leetcode-cn.com/problems/random-pick-with-weight/)——中等]（方法一，前缀和+二分查找，前缀和记录下标对应的区间的左右边界，随机一个数二分查找落在那个区间，返回区间对应的下标。）

```c++
class Solution {
public:
    int sum=0;
    vector<int>ram;
    Solution(vector<int>& w) {
        for(auto x:w){
            sum+=x;
            ram.push_back(sum);//存入前缀和，前缀和左边界为该下标起点，右边界为终点
        }
    }
    int pickIndex() {
        int rnd = rand() % sum,n=ram.size();//随机一个数落在那个区间就选择该区间对应的下标
        int l=0,r=n-1;
        while(l<r){//左右指针相遇跳出
            int mid=l+(r-l)/2;
            if(rnd<ram[mid]){//找到左闭右开区间
                r=mid;
            }
            else{
                l=mid+1;
            }
        }
        return l;//返回下标
    }
};
```

27）[[1109. 航班预订统计](https://leetcode-cn.com/problems/corporate-flight-bookings/)——中等]（方法一，差分数组，区间增量对应差分数组左端点处+增量，右端点+1处-增量，最后前缀和为增加后原数组。）

```c++
//求区间增量用差分数组
class Solution {
public:
    vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {
        vector<int>cha(n);
        for(auto &book:bookings){
            int st=book[0],end=book[1],num=book[2];
            cha[st-1]+=num;//区间左端点加上增量
            if(end<n)   cha[end]-=num;//区间右端点+1的位置减去增量，最后一个位置不做操作
        }
        for(int i=1;i<n;i++){//对差分数组求前缀和
            cha[i]+=cha[i-1];
        }
        return cha;
    }
};
```

28）[[165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)——中等]（方法一，分割字符串，依次比较版本号。）

```c++
class Solution {
public:
    vector<string> cut(string &str){
        vector<string>ans;
        string t="";
        for(auto x:str){
            if(t==""&&x=='0')  continue;//去除前导零
            if(x=='.'){
                if(t!="")
                    ans.push_back(t);
                else    ans.push_back("0");//该版本号为0
                t="";
                continue;
            }
            t+=x;
        }
        if(t!="")   ans.push_back(t);
        return ans;
    }
    int compareVersion(string version1, string version2) {
        vector<string>ver1=cut(version1);
        vector<string>ver2=cut(version2);
        //短的数组中补0
        if(ver1.size()<ver2.size()){
            int n=ver2.size()-ver1.size();
            for(int i=0;i<n;i++){
                ver1.push_back("0");
            }
        }
        else if(ver1.size()>ver2.size()){
            int n=ver1.size()-ver2.size();
            for(int i=0;i<n;i++){
                ver2.push_back("0");
            }
        }
        for(int i=0;i<ver1.size();i++){
            if((stoi(ver1[i]))>(stoi(ver2[i]))) return 1;
            else if((stoi(ver1[i]))<(stoi(ver2[i])))    return -1;
        }
        return 0;
    }
};
```

29）[[470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)——中等]（方法一，利用7*7的矩阵得到49的矩阵，只需要前40的数对10进行取余，取10的概率为4/49。）

```c++
class Solution {
public:
    int rand10() {
        int h,l,idx;
        do{
            h=rand7();
            l=rand7();
            idx=l+(h-1)*7;
        }while(idx>40);取前40
        return 1+(idx-1)%10;//答案从1开始
    }
};
```

30）[[502. IPO](https://leetcode-cn.com/problems/ipo/)——困难]（方法一，贪心+大根堆，将花费从小到大排序，将花费小于等于w的利润加入大根堆，更新w，一共选择k次。）

```c++
class Solution {
public:
    int findMaximizedCapital(int k, int w, vector<int>& profits, vector<int>& capital) {
        int n=profits.size(),cur=0;
        vector<pair<int,int>>arr;
        for(int i=0;i<n;i++){
            arr.push_back({capital[i],profits[i]});//存入[花费，利润]
        }
        sort(arr.begin(),arr.end());//按花费从小到大排序
        //大根堆选择花费小于等于w中利润最大的前k个
        priority_queue<int,vector<int>,less<int>>que;//大根堆
        for(int i=0;i<k;i++){
            while(cur<n&&arr[cur].first<=w){
                que.push(arr[cur].second);//加入大根堆
                cur++;
            }
            if(!que.empty()){
                w+=que.top();
                que.pop();
            }
            else    break;
        }
        return w;
    }
};
```

31）[[68. 文本左右对齐](https://leetcode-cn.com/problems/text-justification/)——困难]（方法一，分割字符串，计算应该插入的平均空格数量和额外多出的空格数量。）

```c++
//计算平均空格：（max-该行单词总长度）/单词数-1；
//额外空格：（max-该行单词总长度）mod单词数-1；
class Solution {
public:
    string countspace(vector<string> &str, int maxWidth,int sumlen,int last) {
        //输出
        /*for(auto x:str){
            cout<<x<<" ";
        }
        cout<<endl;
        cout<<sumlen<<endl;
        */
        string res="";
        //一行只有一个单词
        if(str.size()==1){
            int m=maxWidth-sumlen;
            res+=str[0];
            for(int i=0;i<m;i++)    res+=" ";
            //cout<<res<<endl;
            return res;
        }
        //最后一行的情况
        if(last==1){
            for(int i=0;i<str.size();i++){
                res+=str[i];
                if(i!=str.size()-1)    res+=" ";
            }
            int m=maxWidth-res.size();
            for(int i=0;i<m;i++){
                res+=" ";
            }
            //cout<<res<<endl;
            return res;
        }
        int avgnums=(maxWidth-sumlen)/(str.size()-1);//不能除0
        int extranums=(maxWidth-sumlen)%(str.size()-1);
        //cout<<avgnums<<" "<<extranums<<endl;
        int i;
        //前extra个单词填avg+1个空格
        for(i=0;i<extranums;i++){
            res+=str[i];
            for(int j=0;j<avgnums+1;j++)    res+=" ";
        }
        //后面填avg个空格
        for(;i<str.size();i++){
            res+=str[i];
            if(i!=str.size()-1){
                for(int j=0;j<avgnums;j++)  res+=" ";
            }
        }
        //cout<<res<<endl;
        return res;
    }
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        int n=words.size(),i,sumlen=0;
        vector<string>linshi;
        vector<string>ans;
        linshi.push_back(words[0]);
        sumlen+=words[0].size();
        for(i=1;i<n;i++){
            if(sumlen+linshi.size()+words[i].size()<=maxWidth){
                sumlen+=words[i].size();
                linshi.push_back(words[i]);
            }
            else{
                //cout<<linshi.size()<<endl;
                ans.push_back(countspace(linshi,maxWidth,sumlen,0));
                linshi.clear();
                sumlen=0;
                linshi.push_back(words[i]);
                sumlen+=words[i].size();
            }
        }
        //最后一行
        if(sumlen>0){
            ans.push_back(countspace(linshi,maxWidth,sumlen,1));
        }
        return ans;
    }
};
```

32）[[1894. 找到需要补充粉笔的学生编号](https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/)——中等]（方法一，计算总和取余，使用long long型防止溢出，取余剩下的找到补充位置。）

```c++
class Solution {
public:
    int chalkReplacer(vector<int>& chalk, int k) {
        int n=chalk.size();
        long long sum=0;
        for(int i=0;i<n;i++){
            sum+=chalk[i];//计算总和
        }
        int last=k%sum,ans=0,i;//取余剩下的
        for(i=0;i<n;i++){
            ans+=chalk[i];//判断是否需要补充
            if(ans>last)    break;
        }
        return i;
    }
};
```



# 一、数组

## 1.二分查找

思路：有序数组，无重复元素。

技巧：计算mid时防止超出int型可以使用 mid=left+(right-left)/2 进行计算。

边界条件：

​	1）当target在[left,right]（左右闭区间）内，left==right有意义使用while(left<=right)，当nums[mid]>target时，right应该指向mid-1 。

​	![image-20210720142711240](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210720142711240.png)

​	2）当target在[left,right)（左闭右开区间）内，left==right无意义使用while(left<right)，当nums[mid]>target时，right应该指向mid，仍然为左闭右开区间再次查找。

​	![image-20210720142725551](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210720142725551.png)

### 练习

1）[35 [搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)——简单 ]（方法一，左闭右闭区间二分）

2）[34 [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)——中等 ] （方法一，左闭右闭区间二分，两次二分找到target的左右边界，时间Olog n；方法二，一次左闭右闭区间的二分找到target，边界在该位的两侧，使用for循环找到答案，时间On）

```cpp
//找左边界，当mid严格小于target时左边界右移，最后l为target的左边界
while(l<=r){
	int mid=l+(r-l)/2;
     if(nums[mid]<target){
     	l=mid+1;
   	 }
     else    r=mid-1;
}
//找右边界，当mid严格大于target时右边界左移，最后r为target右边界
while(l<=r){
	int mid=l+(r-l)/2;
	if(nums[mid]>target){
		r=mid-1;
	}
	else    l=mid+1;
}
```

3）[[69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)——简单]（方法一，二分查找，从0到x计算mid*mid是否<=x，记录平方根mid并右移左边界，反之左移右边界，最终找到的答案的平方一定小于等于x故不用验证ans+1）

4）[[367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)——简单]（方法一，二分查找从0到x计算mid*mid是否==num，计算大数mid * mid时需要强转为long long型）

## 2.删除数组元素

数组地址连续，只能覆盖代替删除，时间复杂度高。

思路：快慢指针、数组覆盖（考研数据结构书上算法）

技巧：

```cpp
//相当于快慢指针，覆盖相同元素
for(i=0,j=0;i<n;i++){
	if(nums[i]!=val)
		nums[j++]=nums[i];
}
```

### 练习

1）[[26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)——简单]（方法一，快慢指针，因为数组有序所以下标从1开始，和前面比较不等则存入相等跳过，考虑数组为空的情况。方法二，set去重）

2）[[27. 移除元素](https://leetcode-cn.com/problems/remove-element/)——简单]（方法一，快慢指针，覆盖相同元素）

3）[[283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)——简单]（方法一，快慢指针，非零元素前移，后补0）

4）[[844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/)——简单]（方法一，栈的应用。方法二，逆序双指针记录待删字符数量）

5）[[977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)——简单]（方法一，本身自乘+排序，时间：Onlog。方法二，双指针，因为数组非递减有序，所以平方最大只能为首尾，故双指针指向首尾平方大的逆序存入答案数组，时间On）

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n=nums.size();
        int l=0,r=n-1,pos=n-1;
        vector<int>ans(n);
        while(l<=r){
            //最大的平方只能从首尾出来
            if(nums[l]*nums[l]>nums[r]*nums[r]){
                ans[pos]=nums[l]*nums[l];
                l++;
            }
            else{
                ans[pos]=nums[r]*nums[r];
                r--;
            }
            pos--;
        }
        return ans;
    }
};
```

## 3.滑动窗口

所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。

**字符串与vector互转使用assign()函数，str.assign(vsc.begin(),vsc.end());**

### 练习

1）[[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)——中等]（方法一，滑动窗口，i为起点j为终点，当ij之间的和大于等于target时，右移左边界，时间On。方法二，前缀和+二分查找，时间Onlog）

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int i=0,j,n=nums.size(),res=0x7fffffff,sum=0;
        for(j=0;j<n;j++){
            sum+=nums[j];//每次加上末尾
            while(sum>=target){
                res=min(res,(j-i+1));//子序列长度
                sum-=nums[i];//滑动窗口，每次减去左边界值
                i++;//左边界右移
            }
        }
        return res<0x7fffffff?res:0;
    }
};
```

2）[[904. 水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/)——中等]（方法一，滑动窗口，用map存储两种树，左边界树数量先减减当为0时移除该树号，左边界右移）

```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int n=fruits.size(),i=0,j,res=0;
        if(n==1)    return 1;
        map<int,int>mp;
        for(j=0;j<n;j++){//以j为结尾，i为起点，利用map统计ij中树的种类
            mp[fruits[j]]++;//添加树
            while(mp.size()>2){
                int ctree=fruits[i];//左边界树号
                mp[ctree]--;//左边界数量--
                if(mp[ctree]==0)    mp.erase(ctree);//当左边界的树没有时，移除该树号，跳出循环
                i++;//左边界右移
            }
            res=max(res,j-i+1);//记录答案
        }
        return res;
    }
};
```

3）[[76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)——困难]（方法一，滑动窗口，在ij区间内判断是否包含t子串的字符，包含则右移左边界，不包含左移右边界，记录最短子串）	

**字符串复制函数substr()，string t = str.substr(起点,长度);**

```cpp
class Solution {
public:
    map<char,int>mp,zi;
    bool check(string pos){//利用map检查ij区间内是否包含子串字符
        for(auto &it:zi){
            if(mp[it.first]<it.second)  return false;
        }
        return true;
    }
    string minWindow(string s, string t) {
        int lens=s.length(),lent=t.length(),i,j,res=0x7fffffff;
        string ans="";
        for(j=0;j<lent;j++){//统计子串字符个数
            zi[t[j]]++;
        }
        for(j=0;j<lens;j++){//以j为终点
            mp[s[j]]++;
            while(check(t)&&i<=j){
                if(j-i+1<res){
                    res=j-i+1;
                    ans=s.substr(i,j-i+1);//记录当前最短子串
                }
                if(mp.find(s[i])!=mp.end()){//右移左边界
                    mp[s[i]]--;
                }
                i++;
            }
        }
        return ans;
    }
};
```

4）[[567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)——中等]（方法一，滑动窗口，区间内字符数量相同，维护一个长度为len1的窗口，每次右滑右侧字符数量+1，左侧字符数量-1。）

```c++
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        int len1=s1.size(),len2=s2.size();
        if(len2<len1)   return false;
        //滑动窗口
        vector<int>cou1(26),cou2(26);
        for(int i=0;i<len1;i++){
            ++cou1[s1[i]-'a'];
            ++cou2[s2[i]-'a'];
        }
        if(cou1==cou2)  return true;
        //维护一个长度为len1的窗口
        for(int i=len1;i<len2;i++){
            ++cou2[s2[i]-'a'];//向右滑，右侧+1
            --cou2[s2[i-len1]-'a'];//左侧-1
            if(cou1==cou2)  return true;
        }  
        return false;
    }
};
```



## 4.循环——螺旋遍历

坚持循环不变量原则，保持左闭右开或者左开右闭。

模拟顺时针画矩阵的过程:

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

由外向内一圈一圈这么画下去。

![image-20210721163403701](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210721163403701.png)

### 练习

1）[[54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)——中等]（方法一，模拟外层转圈，设置left，right，top，bottom作为边界）

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int>ans;
        int m=matrix.size(),n=matrix[0].size();
        int left=0,right=n-1,top=0,bottom=m-1;
        while(left<=right&&top<=bottom){
            for(int i=left;i<=right;i++){//上，左闭右闭区间
                ans.push_back(matrix[top][i]);
            }
            for(int i=top+1;i<=bottom;i++){//右，下移一位
                ans.push_back(matrix[i][right]);
            }
            if(left<right&&top<bottom){//一行或一列的情况
                for(int i=right-1;i>left;i--){//下，左移一位，最左不存
                    ans.push_back(matrix[bottom][i]);
                }
                for(int i=bottom;i>top;i--){//左，存到top之下
                    ans.push_back(matrix[i][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
        return ans;
    }
};
```

2）[[59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)——中等]（方法一，模拟外层遍历，同上构建螺旋数组，不用考虑一行或一列，n==1时单独考虑）



# 二、链表

## 1.单链表

![image-20210721165341009](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210721165341009.png)

```c++
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
//使用
ListNode* head = new ListNode(5);//通过自己定义构造函数初始化节点
ListNode* head = new ListNode();//使用默认构造函数初始化节点
head->val = 5;//如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值
```

删除结点：待删结点p

```c++
//1）给了前驱结点q：
q->next = p->next;
//2）给了后继结点s：
p->data = s->data;
p->next = s->next;
```

增加结点：在结点p后增加结点s

```c++
//1)在p后增加s
s->next = p->next;
p->next = s;
//2）在p前增加s
s->next = p->next;
p->next = s;
int val = p->data;//交换结点值
p->data = s->data;
s->data = val;
```

## 2.双链表

![image-20210721165420653](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210721165420653.png)

删除结点：待删结点p

```c++
//删除结点p：
p->prior->next = p->next;
p->next->prior = p->prior;
```

增加结点：增加结点s

```c++
//在p前增加结点s
s->prior = p->prior;
p->prior->next = s;
s->next = p;
p->prior = s;
```

## 3.循环链表

![image-20210721165437468](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210721165437468.png)

删除结点：待删结点p

```c++
//1）给了前驱结点q
q->next = p->next;
//注意首尾删除，删除头需要让尾的next指向头的next，删除尾需要让尾的前一个指向头。
//若删除完链表为空时，首尾指向头结点。
//判别是否指向表尾的判断：
p != L;
p->next != L;
```

增加结点：连接两个循环链表AB，只有尾指针不设头指针

```c++
p = B->next=>next;//去掉B的头
B->next = A->next;//B尾指向A头
A->next = p;//A尾连B
```

## 练习

1）[[138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)——中等]（方法一，利用map将旧结点作为下标新结点作为值存储，由于存在随机指针指向还没建立的结点，遍历map根据旧结点的next和random构建新结点的next和random）

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        map<Node*,Node*>mp;
        if(!head)   return NULL;//特判空指针
        Node *p=head;
        while(p){//利用map，用旧结点为下标，新建结点为值
            mp[p]=new Node(p->val);
            p=p->next;
        }
        p=head;
        while(p){
            mp[p]->next=mp[p->next];
            mp[p]->random=mp[p->random];
            p=p->next;
        }
        return mp[head];
    }
};
```

2）[[203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)——简单]（方法一，快慢指针，如同数组删除，遇到待删数值就跳过，剩下的重新链接）

```c++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        if(!head)   return head;
        ListNode *h=new ListNode(),*p=head,*ans;
        ans=h;//设立头结点
        while(p){
            if(p->val!=val){//若不是删除的数值，链接该节点
                h->next=p;
                h=p; //若该结点不删，h移动到p
            }
            h->next=p->next;//若h和p指向同一位则顺序遍历；若h和p指向不同则跳过其间的结点
            p=p->next;
        }
        return ans->next;
    }
};
```

3）[[707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/)——中等]（方法一，增加和删除需要对size操作，私有成员中有结构体需要将结构体声明放在变量声明之前）

4）[[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)——简单]（方法一，双指针，pre指向null，cur指向当前结点，每次cur指向pre，再整体后移直到链尾。方法二，递归，）

```c++
//方法一，双指针
ListNode* reverseList(ListNode* head) {
	ListNode *p=head,*q=nullptr;
	while(p){
		ListNode *s=p->next;
		p->next=q;
		q=p;
		p=s;
	}
	return q;
}
//方法二，递归
ListNode* reverse(ListNode* pre,ListNode* cur){
	if(!cur)    return pre;//递归终止条件
	ListNode *s=cur->next;
	cur->next=pre;//翻转
	return reverse(cur,s);//如同双指针中pre和cur整体后移一位
}
ListNode* reverseList(ListNode* head) {
	return reverse(nullptr,head);
}
```

5）[[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)——中等]（方法一，多指针，判断pre和cur移动两次后是否越界）

![image-20210722163951640](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210722163951640.png)

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(!head||!head->next)   return head;//0个和1个结点的情况
        ListNode *h=new ListNode(0);//头结点
        h->next=head;
        ListNode *pre=head,*cur=head->next,*q=h;
        while(cur){
            ListNode *s=cur->next;
            q->next=cur;//第一步
            cur->next=pre;;//第二步
            pre->next=s;//第三步
            //整体指针后移
            q=pre;
            pre=s;
            if(!pre)    break;//链表为偶数时，pre已经指空了直接跳出
            cur=pre->next;
        }
        return  h->next;
    }
};
```

6）[[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)——中等]（方法一，快慢指针，找到倒数第n个结点快指针先走n步，慢指针从头结点出发，整体后移至链尾，慢指针所在倒数第n个结点的前一个，直接链接删除）

```c++
ListNode* removeNthFromEnd(ListNode* head, int n) {
	ListNode *h=new ListNode(0);
	h->next=head;//头结点
	ListNode *pre=head,*cur=head,*q=h;
	for(int i=0;i<n;i++){//先走n步
		cur=cur->next;
	}
	while(cur){
		cur=cur->next;
		pre=pre->next;//pre指向倒数第n个结点
		q=q->next;//q指向pre前一个结点
	}
	q->next=pre->next;//删除
	return h->next;
}
```

7）[[面试题 02.07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)——简单]（方法一，双指针，指针指向链尾时换位重头开始直到相遇）

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *p=headA,*q=headB;//各自指向第一个结点
        while(p!=q){
            if(!p){
                p=headB;q=q->next;//指完A链表转到B链头
            }  
            else if(!q){
                q=headA;p=p->next;//指完B链表转到A链头
            } 
            else if(!p&&!q)    return NULL;//当AB都指空时说明两个链表不相交
            else{
                p=p->next;q=q->next;//指针后移
            }
        }
        return p;
    }
};
```

8）[[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)——中等]（方法一，快慢指针找到相遇点，再从头出发一个指针和相遇点出发的指针相遇找到入口点）

![image-20210722174142553](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210722174142553.png)

```c++
//fast指针走的路程：x+y+n(y+z)
//low指针走的路程：x+y
//2倍的low==fast			2(x+y)=x+y+n(y+z)
//x=nz+(n-1)y		若n==1时，从相遇点走到入口点的距离==从头走到入口点的距离
//故设置在头设置指针，相遇点指针一起移动，当二者相遇时即为入口点
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if(!head)   return head;
        ListNode *fast=head,*low=head;
        while(fast->next&&fast->next->next){
            fast=fast->next->next;
            low=low->next;
            if(fast==low){//有环，找到相遇点再找入口
                ListNode *s=head;//从头出发
                while(s!=low){
                    s=s->next;
                    low=low->next;
                }
                return s;
            }
        }
        return NULL;
    }
};
```

## 总结

> 1、增加虚拟头结点有时可以更好完成任务。

> 2、创建链表有头插法和尾插法，设立尾指针。

> 3、找倒数快慢指针快指针先走n步。

> 4、找环快慢指针先找相遇点确定有环，再从头出发新指针和相遇点指针一起移动直到相遇为入口。

> 5、找链表相交双指针到末尾就换位。

# 三、哈希表

散列函数：1.数字分析法	2.平方取中法	3.折叠法	4.除留余数法（常用）

处理冲突方法：1.开放地址法（线性探测法、二次探测法、伪随机探测法）	2.键地址法（如同链表）

1）线性探测法：将散列表想象成循环表，若发生冲突则后移下一位存储。

2）二次探测法：从冲突当前位按照正负i的方查找地址（例如：1，-1,4，-4,9，-9）。

3）伪随机探测法：产生一个伪随机数和冲突地址相加再取余得到新地址存储。

4）键地址法：将具有相同散列地址的元素放入单链表，表头为冲突地址。

![image-20210723120345515](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210723120345515.png)

## 1.数组

## 2.Set

![image-20210723121225828](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210723121225828.png)

### 练习

1）[[349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)——简单]（方法一，set去重，一个for循环st2中是否存在st1中的值，存在则存入答案）

2）[[350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)——简单]（方法一，set去重，如果n在st1和st2中都出现了则为交集，然后用count()函数统计n在nums1和nums2中的个数取最小值作为存入个数）

```c++
//vector中的count()函数应用：count(nums1,begin(),nums1.end(),待查元素);
//其他STL容器count()函数应用：容器名.count(待查元素);
//返回一个数值，没有返回0

//find()函数应用：返回一个迭代器
nums1.find(n)!=nums1.end();//找到元素，返回end()说明没找到
```

3）[[202. 快乐数](https://leetcode-cn.com/problems/happy-number/)——简单]（方法一，set记录每个数，不能有重复的数出现，重复数出现为false。）

## 3.Map

![image-20210723121332183](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210723121332183.png)

### 练习

1）[[242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)——简单]（方法一，用map存储s中每个字符的个数，for遍历t中每个字母若在map中出现则减减，减为0就移除，若map中没有该字母直接返回false，最后返回map的size是否为0，全部删完为true，否则为false。）

2）[[383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)——简单]（方法一，map，同上。方法二，将杂志中的字母ASCII码作为下标存出现数量，遍历信中字母数量减减，若出现小于0则返回false。）

```c++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        vector<int>idx(26);
        for(auto &str:magazine){
            ++idx[str-'a'];
        }
        for(auto &str:ransomNote){
            --idx[str-'a'];//若杂志中没有出现该位字母，减为-1直接返回false
            if(idx[str-'a']<0)  return false;
        }
        return true;
    }
};
```

3）[[49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)——中等]（方法一，map，对每个单词排序作为map的索引，将所有单词存入map<string,vector< string>>中。）

4）[[438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)——中等]（方法一，滑动窗口+哈希map，将目标子串的字母ASCII码作为下标存出现数量，把滑动窗口内的字母同样存入数组，比较两个数组相等时左边界为答案）

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int>ans;
        int lens=s.length(),lenp=p.length();
        if(lens<lenp)   return ans;
        vector<int>ha1(27),ha2(27);
        //目标字串的数组，以字母ASCII码为下标存数量
        for(auto &it:p){
            ++ha1[it -'a'];
        }
        int l=-1;
        for(int i=0;i<lens;i++){
            //滑动窗口大于目标子串，左边界右移，ha2数组删除左边界值
            while(i-l>lenp){
                l++;
                --ha2[s[l] -'a'];
            }
            ++ha2[s[i] -'a'];
            if(ha1==ha2)    ans.push_back(l+1);//目标子串数组和滑动窗口数组相同时，两子串相同
        }
        return ans;
    }
};
```

5）[[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)——简单]（方法一，map记录每个元素所在下标，当target-nums[i]在map中存在时，当前位和mp[ target-nums[i]]满足两数之和。）

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int>mp;
        for(int i=0;i<nums.size();i++){
            if(!mp.count(target-nums[i])){//若map中不存在target-nums[i]
                mp[nums[i]]=i;//map中记录当前元素下标
            }
            else    return {mp[target-nums[i]],i};
        }
        return {};
    }
};
```

6）[[454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)——中等]（方法一，map，统计AB和CD中的两数之数量，用map存，然后遍历两个map，当和为0时，cnt==二者数量的乘积。）

```c++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        unordered_map<int,int>mp1,mp2;
        int i,j,n=nums1.size();
        //AB两数之和：数量
        for(i=0;i<n;i++){
            for(j=0;j<n;j++){
                ++mp1[nums1[i]+nums2[j]];
            }
        }
        //CD两数之和：数量
        for(i=0;i<n;i++){
            for(j=0;j<n;j++){
                ++mp2[nums3[i]+nums4[j]];
            }
        }
        //统计mp1和mp2之和为0的数量
        int cnt=0;
        for(auto &it1:mp1){
            for(auto &it2:mp2){
                if(it1.first+it2.first==0)  cnt+=it1.second*it2.second;
            }
        }
        return cnt;
    }
};
```

7）[[15. 三数之和](https://leetcode-cn.com/problems/3sum/)——中等]（方法一，双指针法，确定三个数，i从0开始，left为i+1，right为n-1。)

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n=nums.size();
        if(n<3) return {};
        sort(nums.begin(),nums.end());
        if(nums[0]>0)   return {};
        vector<vector<int>>ans;
        for(int i=0;i<n;i++){
            if(i>0&&nums[i]==nums[i-1]) continue;//第一个数去重
            int l=i+1,r=n-1;
            while(l<r){
                //若nums[i]+nums[left]+nums[right]大于0，说明三数之和大了，右边界左移
                if(nums[i]+nums[l]+nums[r]>0){
                    r--;
                }
                //若nums[i]+nums[left]+nums[right]小于0，说明三数之和小了，左边界右移
                else if(nums[i]+nums[l]+nums[r]<0){
                    l++;
                }
                else{
                    ans.push_back({nums[i],nums[l],nums[r]});
                    //找到一个三元组后，对后两个数进行去重
                    //若有相等的元素直接跳过
                    while(r>l&&nums[r]==nums[r-1])  r--;
                    while(r>l&&nums[l]==nums[l+1])  l++;
                    //l和r最终停留在和前一个答案相同的地方，再次进行左右收缩
                    l++;r--;
                }
            }
        }
        return ans;
    }
};
```

8）[[18. 四数之和](https://leetcode-cn.com/problems/4sum/)——中等]（方法一，双指针二分+剪枝，在区间i和j内进行二分。）

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        int n=nums.size();
        if(n<4) return {};
        sort(nums.begin(),nums.end());//排序
        if(nums[0]==1000000000) return {};//特例
        vector<vector<int>>ans;
        for(int i=0;i<n-3;i++){
            //去重
            if(i>0&&nums[i]==nums[i-1]) continue;
            //剪枝
            //确定一个数后，若临近的最小三个数之和大于target说明没有满足的四数，直接跳出
            if(nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target)    break;
            //确定一个数后，若数组中最大的三个数之和小于target说明本次没有满足的四数，进行下一次循环
            if(nums[i]+nums[n-3]+nums[n-2]+nums[n-1]<target)    continue;
            for(int j=n-1;j>i+2;j--){
                //去重
                if(j<n-1&&nums[j]==nums[j+1])   continue;
                //剪枝
                //确定两个数后，加上最大的仍小于target，则本次没有符合条件的
                if(nums[i]+nums[j]+nums[n-1]+nums[n-2]<target)    continue;
                int l=i+1,r=j-1;
                while(l<r){
                    if(nums[i]+nums[l]+nums[r]+nums[j]==target){
                        ans.push_back({nums[i],nums[l],nums[r],nums[j]});
                        while(l<r&&nums[l]==nums[l+1])  l++;
                        while(l<r&&nums[r]==nums[r-1])  r--;
                        l++;r--;
                    }
                    else if(nums[i]+nums[l]+nums[r]+nums[j]>target) r--;
                    else    l++;
                }
            }
        }
        return ans;
    }
};
```

# 四、字符串

string转int方法：stoi函数，可以去除先导零

int转string方法：to_string函数

## KMP算法

1、计算next数组

> 每位存最长公共前后缀（前缀表示不包括最后一位的其余，后缀表示不包括第一位的其余），可知一位字母的前后缀都为0，
>
> j指向前缀，从第二位开始若当前位和j位相等则j++赋给i位，若不相等j需要回退到前一个位置再次比较。

```c++
//a  a  b  a  a  f
//0  1  0  1  2  0
void getnext(vector<int> &next,string s){
	int n=next.size(),j=0;//指向前缀
	next[0]=0;//第一位都为0
	for(int i=1;i<n;i++){
		while(j>0&&s[i]!=s[j]){//j移动后出现不相等情况
			j=next[j-1];//当前位不等，j通过next回退上一位
		}//j回退到相等或归零则退出
		if(s[j]==s[i])    j++;//相等j++
		next[i]=j;//赋值
	}
}
```

2、根据next数组匹配模式串位置

> 主串和模式串在ij位上相等i++，j++，不相等模式串回退到next[j-1]位置。

```c++
int strStr(string haystack, string needle) {
	//KMP找到起始点
	int j=0;//模式串起点
	for(int i=0;i<n;i++){//主串起点
		while(j>0&&haystack[i]!=needle[j]){
			j=next[j-1];//不等则回退到上一个
		}
		if(haystack[i]==needle[j]){
			j++;//相等则一块移动
		}
		if(j==m)    return i-m+1;//遍历到模式串末尾返回答案
	}
	return -1;
}
```



### 练习

1）[[344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)——简单]（方法一，双指针，分别指向首尾用swap()函数交换。方法二，c++算法库中reverse函数，写入字符串begin，end迭代器。）

2）[[541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)——简单]（方法一，双指针+区间移动，每次移动2k个位置，找到当前区间首尾。）

3）[[剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)——简单]（方法一，双指针，先重新申请数组，从后向前替换空格。）

```c++
class Solution {
public:
    string replaceSpace(string s) {
        int zeros=0;
        for(auto &it:s) if(it==' ') zeros++;
        int oldn=s.size();
        //重新申请空间
        s.resize(s.size()+zeros*2);
        int n=s.size(),i,j;
        //从后往前存
        for(i=n-1,j=oldn-1;j>=0;){
            if(s[j]!=' '){
                s[i]=s[j];
                i--;j--;
            }
            else{
                s[i--]='0';
                s[i--]='2';
                s[i--]='%';
                j--;
            }
        }
        return s;
    }
};
```

4）[[151. 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)——中等]（方法一，截断字符串+栈，时间On空间On。方法二，去除全部空格，然后整体翻转，再每个单词翻转，空间O1。）

```c++
class Solution {
public:
    void reversestr(string &s,int st,int end){
        while(st<=end){
            swap(s[st],s[end]);
            st++;end--;
        }
    }
    string reverseWords(string s) {
        int n=s.length();
        //移除空格
        int low=0,fast=0;
        while(fast<n&&s[fast]==' ') fast++;
        for(;fast<n;fast++){
            if(fast-1>0&&s[fast]==s[fast-1]&&s[fast]==' ')  continue;
            else{
                s[low++]=s[fast];//可能会存入最后一个空格
            }
        }
        //去除最后一个空格
        if(low-1>0&&s[low-1]==' ')  s.resize(low-1);
        else    s.resize(low);

        //整体翻转
        reversestr(s,0,s.size()-1);//左闭右闭区间

        //每个单词翻转
        int start=0,end=0;
        for(;end<s.size();end++){
            if(s[end]==' '){
                reversestr(s,start,end-1);//左闭右闭区间
                //cout<<start<<" : "<<end<<endl;
                start=end+1;
                
            }
            if(end==s.size()-1)    reversestr(s,start,end);
            //cout<<s<<endl;
        }
        return s;
    }
};
```

5）[[剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)——简单]（方法一，三次翻转，[0,k-1]，[k,lens-1]分别翻转然后整体翻转。）

6）[[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)——简单]（方法一，朴素匹配时间Om*n。方法二，KMP，时间Om+n。）

```c++
class Solution {
public:
    void getnext(vector<int> &next,string s){
        int n=next.size(),j=0;//指向前缀
        next[0]=0;
        for(int i=1;i<n;i++){
            while(j>0&&s[i]!=s[j]){
                j=next[j-1];//当前位不等，j通过next回退上一位
            }//j回退到相等或归零则退出
            if(s[j]==s[i])    j++;
            next[i]=j;
        }
    }
    int strStr(string haystack, string needle) {
        int n=haystack.length(),m=needle.length();
        if(m==0)    return 0;
        //构建next数组
        vector<int>next(m);//为模式串构建next数组
        getnext(next,needle);
        //KMP找到起始点
        int j=0;
        for(int i=0;i<n;i++){
            while(j>0&&haystack[i]!=needle[j]){
                j=next[j-1];//回退到上一个
            }
            if(haystack[i]==needle[j]){
                j++;
            }
            if(j==m)    return i-m+1;
        }
        return -1;
    }
};
```

7）[[459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)——简单]（方法一，next数组找到最长公共前后缀，数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。）

```c++
class Solution {
public:
    void getnext(vector<int> &next,string &s){
        int n=s.length();
        next[0]=0;
        int j=0;
        for(int i=1;i<n;i++){
            //不等时
            while(j>0&&s[i]!=s[j]){
                j=next[j-1];//回退前一个位置
            }
            //相等时
            if(s[i]==s[j])  j++;
            next[i]=j;
        }
    }
    bool repeatedSubstringPattern(string s) {
        int lens=s.length();
        vector<int>next(lens);
        getnext(next,s);
        //注意next最后一位为0
        if(next[lens-1]!=0&&lens%(lens-next[lens-1])==0) return true;
        return false;
    }
};
```

8）[[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)——中等]（方法一，滑动窗口，用set去重，每次移动左指针将其从set中删除，若右指针不在set中将其存入，取每次答案的最大值。）

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n=s.size(),ans=0,rk=-1;//右指针初始为-1
        unordered_set<char>st;//去重
        for(int i=0;i<n;i++){
            if(i!=0)    st.erase(s[i-1]);//左指针移动删除
            while(rk+1<n&&!st.count(s[rk+1])){
                st.insert(s[rk+1]);//右指针加入
                rk++;
            }
            ans=max(ans,rk-i+1);
        }
        return ans;
    }
};
```



# 五、栈与队列

1. C++中stack，queue 是容器么？	不是，stack和queue是容器适配器，底层可以采用不同结构实现
2. 我们使用的stack，queue是属于那个版本的STL？SGI STL里面的数据结构，由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。
3. 我们使用的STL中stack，queue是如何实现的？缺参情况下使用双端队列deque实现，可以自定义使用vector和list
4. stack，queue 提供迭代器来遍历空间么？不提供，只能用top来访问
5. 栈里面的元素在内存中是连续分布的么？不是，底层使用deque不连续，或者使用其他结构也不连续

> 在c++中栈的底层实现使用双端队列deque，不允许遍历不提供迭代器，也可以指定使用vector实现：
>
> ```c++
> std::stack<int, std::vector<int> > third;  // 使用vector为底层容器的栈
> ```
>
> 队列的底层也是用双端队列deque，不允许遍历不提供迭代器，也可以用list实现
>
> ```c++
> std::queue<int, std::list<int>> third; // 定义以list为底层容器的队列
> ```

## 1.优先队列/堆

>优先队列定义：priority_queue<Type, Container, Functional>
>Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆

```c++
//堆是一颗完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。
//优先队列默认大顶堆，每次弹出最大元素
//小顶堆需要重写比较函数
class Cmp{//重写比较函数
	public:
        bool operator()(pair<int,int>x,pair<int,int>y){
            return x.second>y.second;//小顶堆
        }
};
//使用
priority_queue<数据类型, vector<数据类型>, Cmp>que;//小顶堆,cmp自定义数据类型比较
priority_queue<int,vector<int>,greater<int>>que;//小顶堆，自带greater函数比较
priority_queue<int>que;//大顶堆
```

## 2.单调队列

```c++
//单调队列
class myque{
	deque<int>que;//双端队列实现单调队列，递增
	public:
        void pop(int value){
            if(!que.empty()&&que.front()==value){
                que.pop_front();//当需要弹出的元素在队头才弹出否则不需要弹出
            }
        }
        void push(int value){//维护队列中单调递减，存入尽可能大的数值
            while(!que.empty()&&que.back()<value){//存入值与队尾比较，删除小于等于的队尾
                que.pop_back();//将队列中小于存入的都弹出，队内保持最大值
            }
            que.push_back(value);
        }
        int front(){
            return que.front();
        }
};
```

## 练习

1）[[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)——简单]（方法一，双栈，pop()和peek()操作时，若输出栈为空则将输入栈压入输出栈，返回输出栈栈顶。）

2）[[225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)——简单]（方法一，三个队列，push()操作时维护que队列只存最大的数有一个临时队列存其他数，pop()和top()操作返回que的头，若que为空则把临时队列的元素从新压入que中。方法二，一个队列，每次将存入新元素将旧元素依次再入队，使新元素为头。）

3）[[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)——简单]（方法一，符号栈，左括号压入栈，右括号则和栈顶元素比较。）

4）[[1047. 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)——简单]（方法一，每个字母压入栈，和栈顶元素比较若相等则弹出继续下一个，消消乐逻辑。方法二，string提供了出栈入栈接口，pop_back()和push_back()。）

5）[[150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)——中等]（方法一，数值栈遇到符号则弹出两个操作数计算，结果压入数值栈。）

6）[[239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)——困难]（方法一，单调队列，将单调队列头存入答案。）

7）[[347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)——中等]（方法一，小顶堆维持k个数量，最后剩下为前k高频元素。）

# 六、树和二叉树

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

## 1.满二叉树

> 如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

## 2.完全二叉树

> 在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^h -1  个节点。

### 练习

1）[[222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)——中等]（方法一，递归，为空返回0，否则返回递归左右子树之和+1，时间Ologn，空间Ologn。方法二，递归，完全二叉树只有满二叉树和最后一层没有铺满两种情况，对于情况二递归到出现满二叉树为止转换为情况一，时间Ologn*logn，空间Ologn。）

```c++
int count(TreeNode* root){
        if(!root)   return 0;
        TreeNode *left=root->left,*right=root->right;
        int lefth=0,righth=0;
        while(left){//计算层数
            left=left->left;
            lefth++;
        }
        while(right){//计算层数
            right=right->right;
            righth++;
        }
        if(lefth==righth){//满二叉树情况
            return (2<<righth)-1;//等同2^righth次方，2<<1等于2^2次方，故初始值为0
        }
        return  count(root->left)+count(root->right)+1;//不是满二叉树，递归直到找到满二叉树
}
```



## 3.二叉搜索树

> 二叉搜索树是一个有序树。
>
> - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
> - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
> - 它的左、右子树也分别为二叉排序树
> - 中序遍历一定是有序的。

```c++
void searchBST(TreeNode* cur) {
    if (cur == NULL) return ;
    searchBST(cur->left);       // 左
    （处理节点）                // 中
    searchBST(cur->right);      // 右
    return ;
}
```

### 练习

1）[[700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)——简单]（方法一，递归，因为只搜索一条边所以需要返回值。）

```c++
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(!root||root->val==val)   return root;
        if((root->val)<val){//根节点小于目标值，递归右子树
            return searchBST(root->right,val);//需要返回值
        }
        else if((root->val)>val){
            return searchBST(root->left,val);
        }
        return nullptr;
    }
};
```

2）[[98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)——中等]（方法一，递归，中序遍历序列应该递增，若不递增返回false，不能单纯比较根节点与左右结点。）

```c++
class Solution {
public:
    long long minf=LONG_MIN;
    bool isValidBST(TreeNode* root) {
        //不能单纯比较根节点和左右结点的值，有可能右子树存在小于根节点的值或重复值：[3,1,4,null,null,3]
        //[10,5,15,null,null,6,20] 
        if(!root)   return true;
        bool left=isValidBST(root->left);
        if(root->val>minf)  minf=root->val;//中序遍历，序列递增，若不满足则返回false
        else    return false;
        bool right=isValidBST(root->right);
        return left&&right;
    }
};
```

3）[[530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)——简单]（方法一，递归，记录前一个结点。）

4）[[501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)——简单]（方法一，中序遍历，记录当前count和maxcount，当count与maxcount相等时加入答案，若count大于maxcount时需要清空之前答案，重新记录。）

```c++
class Solution {
public:
    vector<int>res;
    TreeNode* pre;
    int count,maxcount;
    void searchBST(TreeNode* root){
        if(!root)   return ;
        searchBST(root->left);
        if(pre==nullptr){//首元素计数为1
            count=1;
        }
        else if(pre->val==root->val)    count++;//前一个元素和当前元素相等，计数+1
        else    count=1;//与前一结点不同
        pre=root;//更新结点
        if(count==maxcount){//当前元素计数等于最大计数加入答案
            res.push_back(root->val);
        }
        if(count>maxcount){//当前计数大于最大计数，清空之前答案重新记录
            maxcount=count;
            res.clear();//清空
            res.push_back(root->val);
        }
        searchBST(root->right);
        return ;
    }
    vector<int> findMode(TreeNode* root) {
        pre=nullptr;
        count=0;
        maxcount=0;
        searchBST(root);
        return res;
    }
};
```

5）[[701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)——中等]（方法一，前序遍历，到空时创建新结点，否则根据搜索树性质，连接左右子树。）

```c++
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(!root){
            return new TreeNode(val);
        }
        if(root->val<val){//当前结点小于插入结点，去右子树
            root->right = insertIntoBST(root->right,val);//上一层的右子树接住下一层传回的结点
        }
        else{//当前结点大于插入结点，去左子树
            root->left = insertIntoBST(root->left,val);//上一层的子树接住下一层传回的结点
        }
        return root;
    }
};
```

6）[[450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)——中等]（方法一，递归，五种删除情况。）

```c++
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(!root)   return root;//1.没找到结点直接返回
        if(root->val==key){
            //2.待删结点为叶子结点，直接删除
            if(!root->left) return root->right;//3.左子树不存在，返回右子树
            else if(!root->right)   return root->left;//4.右子树不存在，返回左子树
            else{//5.左右子树都存在，将左子树连接到右子树最左的位置
                TreeNode* cur=root->right;
                while(cur->left){
                    cur=cur->left;//找到待删节点右子树的最左
                }
                cur->left=root->left;//右子树的最左结点 左连待删节点的左子树
                TreeNode* t=root;
                root=t->right;
                delete t;
                return root;
            }
        }
        root->left=deleteNode(root->left,key);
        root->right=deleteNode(root->right,key);
        return root;
    }
};
```

7）[[669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)——中等]（方法一，递归，从左右子树找到符合区间的返回上一层。）

```c++
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if(!root)   return nullptr;
        if(root->val < low){
            return trimBST(root->right,low,high);//当前结点小于下界，递归右子树，寻找符合区间[low, high]的节点
        }
        else if(root->val > high){
            return trimBST(root->left,low,high);//当前结点大于上界，递归左子树
        }
        root->left=trimBST(root->left,low,high);
        root->right=trimBST(root->right,low,high);
        return root;
    }
};
```

8）[[108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)——简单]（方法一，数组划分左右区间分别建立左右子树。）

```c++
class Solution {
public:
    TreeNode* CreateBST(vector<int>& nums,int left,int right){
        if(left>right)  return nullptr;//越界返回空
        int mid=left+(right-left)/2;
        TreeNode* root=new TreeNode(nums[mid]);//中点新建结点
        root->left=CreateBST(nums,left,mid-1);
        root->right=CreateBST(nums,mid+1,right);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        TreeNode* root=CreateBST(nums,0,nums.size()-1);
        return root;
    }
};
```

9）[[538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)——中等]（方法一，反中序遍历，右中左，每次累加，用pre记录前一结点值。）

![image-20210803162345692](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210803162345692.png)

```c++
class Solution {
public:
    int pre;
    void inorder(TreeNode* root){
        if(!root)   return ;
        inorder(root->right);//右
        root->val+=pre;//中，累加前一个结点值
        pre=root->val;//前一节点换位
        inorder(root->left);//左
    }
    TreeNode* convertBST(TreeNode* root) {
        pre=0;
        inorder(root);
        return root;
    }
};
```



## 4.平衡二叉搜索树

> 又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

> C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。



## 5.遍历

1）前序遍历（根左右）

```c++
//递归方法
void traversal(TreeNode* cur, vector<int>& vec){
    if(!cur){
        vec.push_back(cur->val);
        traversal(cur->left);
        traversal(cur->right);
    }
}
//非递归方法
vector<int> preorderTraversal(TreeNode* root) {
	//非递归
	if(!root)   return {};
	stack<TreeNode*>st;
	vector<int>ans;
	st.push(root);
	while(!st.empty()){
		TreeNode* root=st.top();
		ans.push_back(root->val);//根节点存入
		st.pop();
		if(root->right) st.push(root->right);//先右再左，利用栈
		if(root->left)  st.push(root->left);
	}
	return ans;
}
```

2）中序遍历

```c++
//递归
void traversal(TreeNode* cur, vector<int>& vec){
    if(!cur){
        traversal(cur->left);
        vec.push_back(cur->val);
        traversal(cur->right);
    }
}
//非递归
vector<int> inorderTraversal(TreeNode* root) {
	vector<int>ans;
	stack<TreeNode*>st;
	TreeNode *p=root,*q;
	while(p||!st.empty()){
		if(p){
			st.push(p);
			p=p->left;//指向左子树
		}
		else{
			q=st.top();//指向根
			st.pop();
			ans.push_back(q->val);
			p=q->right;//指向右子树
		}
	}
	return ans;
}
```

3）后序遍历

```c++
//递归
void traversal(TreeNode* cur, vector<int>& vec){
    if(!cur){
        traversal(cur->left);
        traversal(cur->right);
        vec.push_back(cur->val);
    }
}
//非递归
vector<int> postorderTraversal(TreeNode* root) {
	if(!root)   return {};
	vector<int>ans;
	stack<TreeNode*>st;
	st.push(root);
	while(!st.empty()){
		root=st.top();
		st.pop();
		ans.push_back(root->val);//根右左
		if(root->left){
			st.push(root->left);
		}  
		if(root->right){
			st.push(root->right);
		}  
	}
	reverse(ans.begin(),ans.end());//翻转为左右根
	return ans;
}
```

4）层序遍历

```c++
//使用队列层序遍历
vector<vector<int>> levelOrder(TreeNode* root) {
	if(!root)   return {};
	vector<vector<int>>ans;
	queue<TreeNode*>que;
	que.push(root);
	while(!que.empty()){
		int n=que.size();
		vector<int>linshi;
		for(int i=0;i<n;i++){//根据每一层结点数量遍历存入答案
			root=que.front();
			linshi.push_back(root->val);
			if(root->left)  que.push(root->left);
			if(root->right) que.push(root->right);
			que.pop();
		}
		ans.push_back(linshi);
	}
	return ans;
}
```

### 练习

1）[[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)——中等]（方法一，队列，利用层序遍历答案存每层的最后一个值。）

2）[[637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)——简单]（方法一，队列，层序遍历每一层算平均值。）

3）[[515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)——中等]（方法一，队列，层序遍历每一层存最大值。）

4）[[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)——中等]（方法一，队列，层序遍历每一层存入vector然后改变next指针。方法二，递归，题目给定一棵完全二叉树，左孩子next指向右孩子，右孩子next指向父亲next的左孩子。）

```c++
//递归
public void connection(Node root){
	if(root.left == null) return;//没有下一层
	root.left.next=root.right;//左孩子next指向右孩子
	if(root.next != null){
		root.right.next=root.next.left;//右孩子next指向父亲next的左孩子
	}
	connection(root.left);
	connection(root.right);
}
```

5）[[117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)——中等]（方法一，队列层序遍历。方法二，递归，本题不一定为完全二叉树，需要在递归中判断是否存在左右孩子。）

```c++
class Solution {
public:
    Node* findright(Node* t){//找到下一层的最右侧结点
        while(t->next){
            if(t->next->left)   return t->next->left;
            if(t->next->right)  return t->next->right;
            t=t->next;
        }
        return NULL;
    }
    Node* connect(Node* t) {
        if(!t || (!t->left && !t->right)) return t;
        if(t->left&&t->right){
            t->left->next=t->right;
            t->right->next=findright(t);
        }
        //若左边空则先递归右，需要先将右边关系建立好
        if(!t->left){
            t->right->next=findright(t);
        }
        if(!t->right){
            t->left->next=findright(t);
        }
        //先递归右，需要建立右边的关系后再递归左
        t->right=connect(t->right);
        t->left=connect(t->left);
        return t;
    }
};
```

6）[[226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)——简单]（方法一，前序或后序递归，翻转左右孩子，中序不可以会翻转两次左右孩子。）

7）[[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)——简单]（方法一，递归，传入双指针左右子树，递归比较左右子树是否对称，当左右子树为空时返回true，最后返回左右子树递归结果。方法二，非递归，利用队列存入左右子树的头，然后每次依次存入左子树左、右子树右、左子树右、右子树左。）

```c++
//递归
bool pan(TreeNode* t1,TreeNode* t2){
	if(t1==nullptr&&t2!=nullptr)    return false;//一空一存在返回false
	else if(t1!=nullptr&&t2==nullptr)    return false;
	else if(!t1&&!t2)   return true;//都为空返回true
	else if(t1->val != t2->val)    return false;//都存在但值不等返回false
	return pan(t1->left,t2->right)&&pan(t1->right,t2->left);//都存在值相等继续递归，传入镜面的两个指针
}

//非递归
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root)   return true;
        queue<TreeNode*>que;
        que.push(root->left);
        que.push(root->right);
        while(!que.empty()){
            TreeNode* tleft=que.front();que.pop();
            TreeNode* tright=que.front();que.pop();
            if(!tleft&&!tright) continue;//都为空则现在是对称的
            if(!tleft||!tright||(tleft->val!=tright->val)){
                return false;//左右结点有为空时，或左右结点存在但值不等时
            }
            //按顺序依次存入
            que.push(tleft->left);
            que.push(tright->right);
            que.push(tleft->right);
            que.push(tright->left);
        }
        return true;
    }
};
```

8）[[104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)——简单]（方法一，递归，为空返回0，m=递归左子树，n=递归右子树，返回mn中最大值+1。）

9）[[559. N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)——简单]（方法一，递归，取头结点孩子们的最大深度，返回深度+1。）

10）[[111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)——简单]（方法一，递归，左右子树一侧为空最小深度为1+另一侧深度，都存在为最小值+1。）

```c++
int depth(TreeNode* root){
        if(!root)   return 0;
        if(!root->left&&root->right)    return 1+depth(root->right);
        if(!root->right&&root->left)    return 1+depth(root->left);
        return min(depth(root->left),depth(root->right))+1;
}
```

11）[[110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)——简单]（方法一，递归，计算高度差的绝对值大于1返回-1否则返回当前最大高度。）

```c++
int depth(TreeNode* root){
        if(!root)   return 0;
        if(depth(root->left)==-1)   return -1;//左右子树不平衡直接返回-1
        if(depth(root->right)==-1)  return -1;
        return abs(depth(root->left)-depth(root->right))>1?-1:1+max(depth(root->left),depth(root->right));
    	//若左右差值大于1返回-1，否则返回左右子树的最大深度
}
```

12）[[257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)——简单]（方法一，深度优先搜索。）

```c++
void dfs(TreeNode* root,string step){
        if(!root)   return ;
        step+=to_string(root->val);
        if(!root->left&&!root->right){//到达叶子结点为一个路径 存储
            ans.push_back(step);
            return ;
        }   
        step+="->";
        dfs(root->left,step);
        dfs(root->right,step);
}
```

13）[[404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)——简单]（方法一，中序遍历传入父指针。）

14）[[513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)——中等]（方法一，层序遍历记录每层最左。方法二，递归，传入深度值，每次回溯在叶子结点记录。）

## 6.递归

> 如果需要搜索整颗二叉树，那么递归函数就不要返回值，如果要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径了就要及时返回。

```c++
//搜索一条边
if (递归函数(root->left)) return ;

if (递归函数(root->right)) return ;

//搜索整棵树
left = 递归函数(root->left);
right = 递归函数(root->right);
left与right的逻辑处理;
```



### 练习

1）[[112. 路径总和](https://leetcode-cn.com/problems/path-sum/)——简单]（方法一，递归回溯，问题需要找一条符合条件的路径需要返回值，当到达叶子结点且target为0时返回true。）

2）[[113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)——中等]（方法一，递归回溯，需要遍历全树找多条路径不需要返回值，将当前结点存入临时数组，满足条件则将临时数组存入答案数组，然后递归左右子树。）

3）[[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)——中等]（方法一，递归，切割中序后序数组。）

```c++
class Solution {
public:
    TreeNode* CreateTree(vector<int>& inorder, vector<int>& postorder){
        //空结点
        if(inorder.size()==0)   return nullptr;
        int data=postorder[postorder.size()-1];
        TreeNode* root=new TreeNode(data);
        //叶子结点
        if(postorder.size()==1) return root;

        //切割中序数组，左闭右开
        int inidx=0;
        for(;inidx<inorder.size();inidx++){
            if(inorder[inidx]==data)    break;
        }
        vector<int>leftino(inorder.begin(),inorder.begin()+inidx);//[0,inidx)
        vector<int>rightino(inorder.begin()+inidx+1,inorder.end());//[inidx+1,end)

        //后序数组舍弃末尾元素
        postorder.resize(postorder.size()-1);

        //切割后序数组，左闭右开
        vector<int>leftpos(postorder.begin(),postorder.begin()+leftino.size());//[0,inidx)
        vector<int>rightpos(postorder.begin()+leftino.size(),postorder.end());//[inidx,end)

        root->left=CreateTree(leftino,leftpos);
        root->right=CreateTree(rightino,rightpos);
        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if(inorder.size()==0||postorder.size()==0)  return nullptr;
        return CreateTree(inorder,postorder);
    }
};
```

4）[[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)——中等]（方法一，递归分割前序中序数组，可以利用map存储结点对应的下标从而快速找到分割点。）

```c++
class Solution {
private:
    unordered_map<int,int>index;
public:
    TreeNode* creattree(vector<int>& preorder, vector<int>& inorder,int left_pre,int right_pre,int left_ino,int right_ino){
        if(left_pre>right_pre){
            return nullptr;
        }
        int pre_root=left_pre;//根节点在前序中的位置
        int ino_root=index[preorder[pre_root]];//根节点在中序中的位置
        TreeNode* T=new TreeNode(preorder[pre_root]);
        //得到左子树的个数
        int size_left_pre=ino_root-left_ino;//中序根节点位置键中序最左位置
        //递归左子树
        T->left=creattree(preorder,inorder,left_pre+1,left_pre+size_left_pre,left_ino,ino_root-1);
        T->right=creattree(preorder,inorder,left_pre+size_left_pre+1,right_pre,ino_root+1,right_ino);
        return T;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int i,n=preorder.size();
        for(i=0;i<n;i++){
            index[inorder[i]]=i;
        }
        return creattree(preorder,inorder,0,n-1,0,n-1);
    }
};
```

5）[[654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)——中等]（方法一，递归前序建树，分割最大值两侧成为新数组。）

```c++
class Solution {
public:
    TreeNode* CreateTree(vector<int>& nums){
        if(nums.size()==0)  return nullptr;
        int maxdata=0,flag;
        for(int i=0;i<nums.size();i++){
            if(nums[i]>maxdata){
                maxdata=nums[i];
                flag=i;
            }
        }
        TreeNode* root=new TreeNode(maxdata);
        if(nums.size()==1)  return root;
        //分割
        vector<int>leftnums(nums.begin(),nums.begin()+flag);
        vector<int>rightnums(nums.begin()+flag+1,nums.end());

        root->left=CreateTree(leftnums);
        root->right=CreateTree(rightnums);
        return root;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        if(nums.size()==0)  return nullptr;
        return CreateTree(nums);
    }
};
```

6）[[617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)——简单]（方法一，前序递归，t1为空返回t2，t2为空返回t1，都存在结点值相加。）



## 7.二叉树最近公共祖先

1. 求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从低向上的遍历方式。
2. 在回溯的过程中，必然要遍历整颗二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。
3. 要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。
4. ![image-20210802163401662](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210802163401662.png)

### 练习

1）[[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)——中等]（方法一，dfs。方法二，后续遍历回溯，返回最近公共祖先到头结点。）

```c++
//方法一
class Solution {
public:
    TreeNode* ans;
    bool dfs(TreeNode* root,TreeNode* p,TreeNode* q){
        if(root==NULL)  return false;
        bool fl=dfs(root->left,p,q);
        bool fr=dfs(root->right,p,q);
        if( (fl&&fr) || ((p->val==root->val||q->val==root->val) && (fl||fr)) ){
            //1.pq存在于当前结点的左右子树，则当前结点为最近父节点
            //2.当前结点的值等于qp某一个的值且当前结点是pq之一的父节点
            ans=root;
        }
        return fl||fr||(p->val==root->val||q->val==root->val);
    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        dfs(root,p,q);
        return ans;
    }
};

//方法二
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==q||root==p||!root) return root;
        TreeNode* left=lowestCommonAncestor(root->left,p,q);//左
        TreeNode* right=lowestCommonAncestor(root->right,p,q);//右
        if(left&&right) return root;//根，找到最近公共祖先
		//最后公共祖先会传到头，
        if(!left&&right)   return right;
        else if(left&&!right)   return left;
        else    return NULL;
    }
};
```

2）[[235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)——简单]（方法一，后序遍历从下往上。方法二，根据二叉搜索树中序遍历有序的特点，找到在pq结点值之间的结点即为最近公共祖先。）

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(!root)   return NULL;
        if(root->val > p->val && root->val > q->val){//当前结点大于pq结点，去左边
            return lowestCommonAncestor(root->left,p,q);
        }
        else if(root->val < p->val && root->val < q->val){//当前结点小于pq结点，去右边
            return lowestCommonAncestor(root->right,p,q);
        }
        else    return root;
    }
};
```

# 七、回溯算法

```c++
//若在某一子结点符合条件且只找一条路径，返回值为bool；
//找到全部满足条件的答案，返回值为void。
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

![image-20210805144108113](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210805144108113.png)

## 1.组合问题

> N个数里面按一定规则找出k个数的集合(组合无序，排列有序)
>
> 时间复杂度：O(n * 2^n)
>
> 空间复杂度：O(n)，包括系统栈

![image-20210808181702166](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210808181702166.png)

### 练习

1）[[77. 组合](https://leetcode-cn.com/problems/combinations/)——中等]（方法一，回溯，dfs(临时数组，子序列需要长度，当前数，最大长度)。）

```c++
class Solution {
public:
    vector<vector<int>>ans;
    void dfs(vector<int> &linshi,int k,int cur,int n){
        if(linshi.size()==k){//满足条件，存入答案，返回上一层
            ans.push_back(linshi);
            return;
        }
        //可以优化剪枝：若n=4，k=4时，后续结点都可以不用遍历，因为无法满足条件
        //可以将遍历改为：for(int i=cur;i<=n-(k-linshi.size())+1;i++)
        for(;cur<=n;cur++){//从当前点开始，若当前点超过范围则不存入临时数组
            linshi.push_back(cur);//加入当前点
            dfs(linshi,k,cur+1,n);//递归下一个点
            linshi.pop_back();//弹出，继续找下一个数
        }
    }
    vector<vector<int>> combine(int n, int k) {
        vector<int>linshi;
        dfs(linshi,k,1,n);
        return ans;
    }
};
```

2）[[216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)——中等]（方法一，回溯，dfs(临时数组，当前数，当前和，n，k)。）

```c++
class Solution {
public:
    vector<vector<int>>ans;
    void dfs(vector<int> &linshi,int cur,int sum,int n,int k){
        if(linshi.size()==k&&sum==n){//符合题意，存入答案
            ans.push_back(linshi);
            return ;
        }
        //剪枝操作：若sum大于目标可以直接返回上一层
        for(;cur<=9;cur++){//遍历剩下的数
            sum+=cur;
            linshi.push_back(cur);
            dfs(linshi,cur+1,sum,n,k);
            sum-=cur;//回溯
            linshi.pop_back();//回溯
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<int>linshi;
        dfs(linshi,1,0,n,k);
        return ans;
    }
};
```

3）[[17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)——中等]（方法一，回溯，利用map存手机的九宫格，传入当前位置idx，每次加入digits[idx]对应的字符串中某一个字符，然后idx+1进入递归第二位的字母。）

```c++
class Solution {
public:
    vector<string>ans;
    map<char,string>mp={{'2',"abc"},{'3',"def"},{'4',"ghi"},{'5',"jkl"},{'6',"mno"},{'7',"pqrs"},{'8',"tuv"},{'9',"wxyz"}};
    void dfs(string &linshi,string &digits,int idx,int n){
        if(linshi.length()==n){
            ans.push_back(linshi);
            return ;
        }
        for(;idx<n;idx++){
            int m=mp[digits[idx]].size();
            for(int i=0;i<m;i++){
                linshi+=mp[digits[idx]][i];
                dfs(linshi,digits,idx+1,n);
                linshi.pop_back();//回溯
            }
        }
    }
    vector<string> letterCombinations(string digits) {
        int n=digits.length();
        if(n==0)    return {};//特判
        string linshi;
        dfs(linshi,digits,0,n);
        return ans;
    }
};
```

4）[[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)——中等]（方法一，回溯，因为可以重复使用，在回溯中下标不用+1。）

```c++
class Solution {
public:
    vector<vector<int>>ans;
    void dfs(vector<int> &linshi,vector<int>& candidates,int sum,int idx,int target){
        if(sum==target){
            ans.push_back(linshi);
            return;
        }
        if(sum>target)  return ;
        for(;idx<candidates.size();idx++){
            linshi.push_back(candidates[idx]);
            sum+=candidates[idx];
            dfs(linshi,candidates,sum,idx,target);//可以重复使用，idx不用+1
            sum-=candidates[idx];
            linshi.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<int> linshi;
        dfs(linshi,candidates,0,0,target);
        return ans;
    }
};
```

5）[[40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)——中等]（方法一，回溯，数组排序后，遇到前后两位相同则跳过，建立used数组标记使用过的元素。）

```c++
class Solution {
public:
    vector<vector<int>>ans;
    void dfs(vector<int> &linshi,vector<int>& candidates,vector<bool> &used,int sum,int idx,int target){
        if(sum==target){
            ans.push_back(linshi);
            return ;
        }
        if(sum>target)  return ;
        for(;idx<candidates.size();idx++){
            //前一位等于当前数跳过	// 要对同一树层使用过的元素进行跳过
            if(idx>0&&candidates[idx]==candidates[idx-1]&&used[idx-1]==false) continue;
            linshi.push_back(candidates[idx]);
            sum+=candidates[idx];
            used[idx]=true;//当前位使用
            dfs(linshi,candidates,used,sum,idx+1,target);
            used[idx]=false;//回溯
            sum-=candidates[idx];
            linshi.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<int>linshi;
        vector<bool>used(candidates.size(),false);//去重数组
        sort(candidates.begin(),candidates.end());//排序
        dfs(linshi,candidates,used,0,0,target);
        return ans;
    }
};
```



## 2.切割问题

> 一个字符串按一定规则有几种切割方式
>
> 时间复杂度：O(n * 2^n)
>
> 空间复杂度：O(n)，包括系统栈

![image-20210808181617336](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210808181617336.png)

### 练习

1）[[131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)——中等]（方法一，回溯，在for循环内递归以下一位开始的字符串，**切割过的地方不能重复切割所以递归函数需要传入i + 1**。）

```c++
class Solution {
public:
    vector<vector<string>> ans;
    vector<string> linshi;
    bool ishui(const string s,int st,int end){
        while(st<end){
            if(s[st]!=s[end])   return false;
            st++;
            end--;
        }
        return true;
    }
    void dfs(const string &s,int st){
        if(st>=s.size()){
            ans.push_back(linshi);
            return ;
        }
        for(int i=st;i<s.size();i++){
            if(ishui(s,st,i)){
                string str=s.substr(st,i-st+1);
                linshi.push_back(str);
            }
            else    continue;
            dfs(s,i+1);//以下一位为起点，切割过的地方不能重复切割所以递归函数需要传入i + 1。
            linshi.pop_back();
        }
    }
    vector<vector<string>> partition(string s) {
        dfs(s,0);
        return ans;
    }
};
```

2）[[93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)——中等]（方法一，回溯，在原字符串插入点，依次判断每次分割子字符串是否满足ip条件。）

```c++
class Solution {
public:
    vector<string>ans;
    bool isip(const string &s,int st,int end){
        if(st>end)  return false;
        if(s[st]=='0'&&st!=end) return false;
        int num=0;
        for(;st<=end;st++){
            if(s[st]<'0'||s[st]>'9')    return false;
            num = num*10+(s[st]-'0');
            if(num>255) return false;
        }
        return true;
    }
    void dfs(string &s,int st,int poinnum){
        if(poinnum==3){
            if(isip(s,st,s.size()-1)){
                ans.push_back(s);
            }
            return ;
        }
        for(int i=st;i<s.size();i++){
            if(isip(s,st,i)){
                s.insert(s.begin()+i+1,'.');//需要修改字符串s，传入参数不能加const
                poinnum++;
                dfs(s,i+2,poinnum);//跳过刚插入的点
                poinnum--;
                s.erase(s.begin()+i+1);//删除点
            }
            else    break;//跳出
        }
    }
    vector<string> restoreIpAddresses(string s) {
        if(s.size()>12) return ans;
        dfs(s,0,0);
        return ans;
    }
};
```



## 3.子集问题

> 一个N个数的集合里有多少符合条件的子集
>
> 时间复杂度：O(n * 2^n)
>
> 空间复杂度：O(n)，包括系统栈

![image-20210808181354381](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210808181354381.png)

### 练习

1）[[78. 子集](https://leetcode-cn.com/problems/subsets/)——中等]（方法一，回溯，每个子集都要存入答案，不需要剪枝。）

```c++
class Solution {
public:
    void dfs(int idx,vector<int>& nums,vector<int>& linshi,vector<vector<int>>& ans){
        //如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！
        ans.push_back(linshi);//存入每个子集
        if(idx>=nums.size()){
            return ;
        }
        for(;idx<nums.size();idx++){
            linshi.push_back(nums[idx]);
            dfs(idx+1,nums,linshi,ans);
            linshi.pop_back();
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        //DFS回溯
        vector<int>linshi;
        vector<vector<int>>ans;
        dfs(0,nums,linshi,ans);
        return ans;
    }
};
```

2）[[90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)——中等]（方法一，排序+回溯，排序后相同元素相邻，可以比较前一个跳过相同元素的递归。）

```c++
class Solution {
public:
    vector<vector<int>>ans;
    vector<int>linshi;
    void dfs(int idx,vector<int> &nums){
        ans.push_back(linshi);
        if(idx>=nums.size())    return ;
        for(int i=idx;i<nums.size();i++){
            if(i>idx&&nums[i]==nums[i-1])   continue;//去重,排序后相同元素相邻
            linshi.push_back(nums[i]);
            dfs(i+1,nums);
            linshi.pop_back();
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        dfs(0,nums);
        return ans;
    }
};
```

3）[[491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)——中等]（方法一，回溯+去重，设置数组标记每层使用的元素，同一父节点下的同层上使用过的元素就不能在使用了。）

```c++
class Solution {
public:
    vector<vector<int>>ans;
    vector<int>linshi;
    void dfs(int idx,vector<int> &nums){
        if(linshi.size()>1){//递增子序列大于1就存入答案
            ans.push_back(linshi);
        }
        vector<int>set(201,0);//记录当前层使用过的元素
        for(int i=idx;i<nums.size();i++){
            //跳过的两种情况：1.子序列存在下一个数小于递增子序列末尾；2.当前元素使用过
            if((!linshi.empty()&&linshi.back()>nums[i]) || set[nums[i]+100]==1) 
                continue;
           	//当前元素大于等于递增子序列的最后一个元素
            set[nums[i]+100]=1;
            linshi.push_back(nums[i]);
            dfs(i+1,nums);
            linshi.pop_back();
        }
    }
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        dfs(0,nums);
        return ans;
    }
};
```



## 4.排列问题

> N个数按一定规则全排列，有几种排列方式
>
> 时间复杂度：O(n!)
>
> 空间复杂度：O(n)，包括系统栈

![image-20210808181424520](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210808181424520.png)

### 练习

1）[[46. 全排列](https://leetcode-cn.com/problems/permutations/)——中等]（方法一，回溯，遍历所有组合，长度相等时加入答案。）

```c++
class Solution {
public:
    vector<vector<int>>ans;
    vector<int>linshi;
    void dfs(vector<int>& nums){
        if(linshi.size()==nums.size()){
            ans.push_back(linshi);
            return;
        }
        for(int i=0;i<nums.size();i++){//从0开始遍历所有
            if(count(linshi.begin(),linshi.end(),nums[i]))  continue;//出现重复元素跳过
            else{
                linshi.push_back(nums[i]);
                dfs(nums);
                linshi.pop_back();
            }
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        dfs(nums);
        return ans;
    }
};
```

2）[[47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)——中等]（方法一，排列问题，回溯，有相同元素使用map标记使用元素，排序后有重复元素去重。）

```c++
class Solution {
public:
    vector<vector<int>>ans;
    vector<int>linshi;
    map<int,int>mp;
    void dfs(vector<int>& nums){
        if(linshi.size()==nums.size()){
            ans.push_back(linshi);
            return ;
        }
        for(int i=0;i<nums.size();i++){
            if(i>0&&nums[i]==nums[i-1]) continue;//有重复元素时，同层去重，必须有序
            if(!mp[nums[i]])    continue;//元素使用完，跳过
            else{
                linshi.push_back(nums[i]);
                --mp[nums[i]];
                dfs(nums);
                ++mp[nums[i]];
                linshi.pop_back();
            }
        }
    }
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        for(int n:nums){
            ++mp[n];
        }
        dfs(nums);
        return ans;
    }
};
```



## 5.棋盘问题

> N皇后，解数独等等
>
> N皇后：时间复杂度：O(n!)，空间复杂度：O(n)，包括系统栈
>
> 解数独：时间复杂度：O(9^m)，m是空格数，空间复杂度：O(n^2)，递归深度

### 练习

1）[[332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)——中等]（方法一，回溯，利用map存储两地之间关系，出发和到达会重复记录每条航班的数量，返回类型变为bool，回溯到某一节点完成直接返回，不再继续。）

```c++
class Solution {
public:
    unordered_map<string,map<string,int>>targets;// unordered_map<出发机场, map<到达机场, 航班次数>> targets
    bool dfs(vector<string> &ans,int n){
        if(ans.size()==n+1) return true;//只需找到一条路径即可
        for(auto &it:targets[ans[ans.size()-1]]){//根据最后一个答案地点，取出map<目的地，航班路线>
            if((it.second)>0){
                ans.push_back(it.first);//存入终点
                it.second--;//线路数减一
                if(dfs(ans,n))  return true;//下一层找到答案
                it.second++;
                ans.pop_back();
            }
        }
        return false;
    }
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        vector<string>ans;
        ans.push_back("JFK");
        for(auto t:tickets){
            targets[t[0]][t[1]]++;//航班线路++
        }
        dfs(ans,tickets.size());
        return ans;
    }
};
```

2）[[51. N 皇后](https://leetcode-cn.com/problems/n-queens/)——困难]（方法一，回溯，皇后约束条件：1.不能同行；2.不能同列；3.不能同斜线，for循环每次从0开始，控制一行一个，再验证不同列不同斜线即可。）

```c++
class Solution {
public:
    vector<vector<string>>ans;
    bool isvalid(int n,int row,int col,vector<string> &linshi){
        //45度
        for(int i=0;i<n;i++){
            if((row-i)>=0&&(col+i)<n&&linshi[row-i][col+i]=='Q')   return false;
        }
        //90度
        for(int i=0;i<n;i++){
            if((row-i)>=0 && linshi[row-i][col]=='Q') return false;
        }
        //135度
        for(int i=0;i<n;i++){
            if((row-i)>=0&&(col-i)>=0&&linshi[row-i][col-i]=='Q')   return false;
        }
        return true;
    }
    void dfs(int n,int row,vector<string> &linshi){
        if(row==n){
            ans.push_back(linshi);
            return ;
        }
        for(int col=0;col<n;col++){//每列从0开始
            if(isvalid(n,row,col,linshi)){//如果位置合法
                linshi[row][col]='Q';
                dfs(n,row+1,linshi);
                linshi[row][col]='.';//回溯
            }
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        vector<string>linshi(n,string(n,'.'));//初始化
        dfs(n,0,linshi);
        return ans;
    }
};
```

3）[[37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)——困难]（方法一，回溯，遍历二维数组每个位置，依次填入1-9，判断是否满足条件，满足返回true结束。）

```c++
class Solution {
public:
    bool isvalid(int h,int l,char val,vector<vector<char>> &board){
        int n=board.size();
        //同行
        for(int i=0;i<n;i++){
            if(board[h][i]==val)    return false;
        }
        //同列
        for(int i=0;i<n;i++){
            if(board[i][l]==val)    return false;
        }
        //同一九宫格
        int row=(h/3)*3,col=(l/3)*3;
        for(int i=row;i<row+3;i++){
            for(int j=col;j<col+3;j++){
                if(board[i][j]==val)    return false;
            }
        }
        return true;
    }
    bool dfs(vector<vector<char>>& board){
        for(int i=0;i<board.size();i++){
            for(int j=0;j<board[0].size();j++){
                if(board[i][j]!='.')    continue;
                for(char k='1';k<='9';k++){
                    if(isvalid(i,j,k,board)){//位置合格
                        board[i][j]=k;
                        if(dfs(board))  return true;//下一层找到答案直接返回
                        board[i][j]='.';//回溯
                    }
                }
                return false;//同一层内没有合适位置，无解
            }
        }
        return true;
    }
    void solveSudoku(vector<vector<char>>& board) {
        dfs(board);
    }
};
```

# 八、贪心算法

> **贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。

## 1.普通贪心问题

### 练习

1）[[376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)——中等]（方法一，贪心，记录差值的峰值依次比较。）

```c++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int n=nums.size();
        int cur=0,pre=0;//记录当前差值和前一个差值
        int ans=1;
        for(int i=1;i<n;i++){
            cur=nums[i]-nums[i-1];
            if((cur>0&&pre<=0)||(cur<0&&pre>=0)){//两种情况。
                ans++;
                pre=cur;
            }
        }
        return ans;
    }
};
```

2）[[53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)——简单]（方法一，贪心，在局部最优解中count已经为负数时，再加负数必定拉低总和，故count小于等于0后直接变为0重新记录。方法二，动态规划，转移方程：当前数和之前的和+当前数 二者间最大值存入。）

```c++
//贪心：不能让“连续和”为负数的时候加上下一个元素，而不是 不让“连续和”加上一个负数
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n=nums.size();
        int count=0,ans=INT_MIN;
        for(int i=0;i<n;i++){
            count+=nums[i];//记录和
            if(count>ans)   ans=count;//记录最大值
            if(count<=0)    count=0;//计数小于等于0后，归0
        }
        return ans;
    }
};
//动态规划
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n=nums.size(),ans=nums[0];//答案初始为第一个数
        vector<int>dp(n);
        dp[0]=nums[0];
        for(int i=1;i<n;i++){
            dp[i]=max(nums[i],dp[i-1]+nums[i]);//转移方程
            ans=max(dp[i],ans);
        }
        return ans;
    }
};
```

3）[[122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)——简单]（方法一，找单调递增区间。方法二，盈利可以拆解为每日的盈利，将每日正盈利相加即为最大盈利。）

```c++
//找到单调增区间端点，和相加
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size(),st=0,ans=0,i;
        if(n==1)    return 0;
        for(i=1;i<n;){
            if(prices[i]>prices[i-1]){
                i++;
            }
            else{
                if(i-st>1)  ans+=prices[i-1]-prices[st];
                st=i;
                i++;
            }
        }
        if(prices[i-1]>prices[st])   ans+=prices[i-1]-prices[st];
        return ans;
    }
};
//贪心算法
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size(),ans=0;
        for(int i=1;i<n;i++){
            ans+=max(prices[i]-prices[i-1],0);//每日盈利为正，相加
        }
        return ans;
    }
};
```

4）[[1005. K 次取反后最大化的数组和](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/)——简单]（方法一，贪心，利用优先队列取前k个最小的取反。）

```c++
class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        //取前k个最小的取反，优先队列
        int ans=0;
        priority_queue<int,vector<int>,greater<int>>que;//小顶堆
        for(int a:nums){
            que.push(a);
        }
        for(int i=0;i<k;i++){
            int a=que.top();
            que.pop();
            que.push(-a);
        }
        while(!que.empty()){
            int a=que.top();
            ans+=a;
            que.pop();
        }
        return ans;
    }
};
```

5）[[134. 加油站](https://leetcode-cn.com/problems/gas-station/)——中等]（方法一，暴力，遍历每个可能作为起始的位置，(idx+1)%n保证循环。方法二，贪心，记录每个油箱剩余油量，若为负起始点换位i+1。）

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        //贪心
        int n=gas.size();
        int st=0,cursum=0,sum=0;
        for(int i=0;i<n;i++){
            cursum+=gas[i]-cost[i];//每个油箱去到下一个油箱的剩余量
            sum+=gas[i]-cost[i];
            if(cursum<0){//说明从st出发到达i时，凭借之前的剩余油量不足以到达下一个，故st需要从i+1位置开始
                st=i+1;//如果当前剩余量不足以去下一个油箱，起始位置变为i+1
                cursum=0;
            }
        }
        if(sum<0)   return -1;//全程油箱剩余量小于0，说明不可能走完
        return st;
    }
};
```

6）[[860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)——简单]（方法一，模拟三种情况，花费20的时候需要尽可能使用10元。）

## 2.跳跃问题

### 练习

> 维护一个右边界，当右边界包含末尾则表明可以跳过

1）[[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)——中等]（方法一，贪心，维护可以跳过的最大距离，若最大距离超过最大下标表示可以跳过去。）

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n=nums.size();
        if(n==1)    return true;
        int maxstep=0;
        for(int i=0;i<=maxstep;i++){//在最大范围内遍历，更新最大范围
            maxstep=max(maxstep,i+nums[i]);//取最大范围
            if(maxstep>=n-1)    return true;
        }
        return false;
    }
};
```

2）[[45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)——中等]（方法一，贪心，维护两个最大距离，一个是当前可以到达的最大，一个是下一位最大距离，若走到当前最大距离判断是否为最后位置。）

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int n=nums.size(),step=0;
        if(n==1)    return 0;
        int maxstep=0,cur=0;
        for(int i=0;i<n;i++){
            maxstep=max(i+nums[i],maxstep);//下一位最远下标
            if(i==cur){//走到现在的最远下标
                if(cur!=n-1){//当前没有走到最后一个位置
                    step++;//步数+1
                    cur=maxstep;//更新当下最远下标
                    if(maxstep>=n-1)    break;//下一步最远下标超过范围，跳出
                }
                else    break;
            }
        }
        return step;
    }
};
//简化版：因为必可达最后一个位置，如果最大范围覆盖到倒数第二个位置则step+1即为答案
//2  3  1  1  4
class Solution {
public:
    int jump(vector<int>& nums) {
        int n=nums.size(),step=0;
        if(n==1)    return 0;
        int maxstep=0,cur=0;
        for(int i=0;i<n-1;i++){//只到倒数第二个位置
            maxstep=max(maxstep,nums[i]+i);
            if(i==cur){
                cur=maxstep;
                step++;
            }
        }
        return step;
    }
};
```

## 3.左右二维贪心问题

### 练习

> 确定某一维度为主，多次贪心解决问题

1）[[135. 分发糖果](https://leetcode-cn.com/problems/candy/)——困难]（方法一，贪心，两次贪心从左往右和从右往左。）

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        //两次贪心，从左向右，从右向左
        int n=ratings.size(),ans=0;
        vector<int>candys(n,1);
        //从左向右
        for(int i=1;i<n;i++){
            if(ratings[i]>ratings[i-1])   candys[i]=candys[i-1]+1;//右边大于左边,左边+1赋给右边
        }
        //从右向左
        for(int i=n-2;i>=0;i--){
            if(ratings[i]>ratings[i+1]) candys[i]=max(candys[i],candys[i+1]+1);//左边大于右边，取右边+1和左边最大值赋给左边
        }
        for(int i=0;i<n;i++)    ans+=candys[i];
        return ans;
    }
};
```

2）[[406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)——中等]（方法一，从高到低排序，相同k小的在前，然后按照k重新插入，将矮的插入到高的前对于高的k没有影响。）

```c++
class Solution {
public:
    static bool cmp(vector<int>a,vector<int>b){
        if(a[0]==b[0])  return a[1]<b[1];
        return a[0]>b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        //从高到低排序
        sort(people.begin(),people.end(),cmp);
        //按k插入
        vector<vector<int>>ans;
        for(auto &p:people){//将矮的插入到高的前，对于高的k没有影响
            ans.insert(ans.begin()+p[1],p);
        }
        return ans;
    }
};
```

## 4.区间贪心

### 练习

> 对区间排序，从左到右贪心

1）[[452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)——中等]（方法一，排序，更新右边界情况。）

```c++
class Solution {
public:
    static bool cmp(vector<int>a,vector<int>b){
        if(a[1]==b[1])  return a[0]<b[0];
        return a[1]<b[1];
    }
    int findMinArrowShots(vector<vector<int>>& points) {
        int n=points.size();
        sort(points.begin(),points.end(),cmp);
        int ans=1,end=points[0][1];//记录第一个右边界
        for(int i=1;i<n;i++){
            if(points[i][0]<=end)   continue;//若下一个气球的起始小于等于右边界，可一箭射中，跳过
            else{//下一个气球起始大于右边界，箭数+1，右边界改变
                ans++;
                end=points[i][1];
            }
        }
        return ans;
    }
};
```

2）[[435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)——中等]（方法一，按右端点排序，统计区间内不重叠个数，最后n减去得到答案，cmp函数中传入const静态变量更快。）

```c++
class Solution {
public:
    static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[1] < b[1];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        int n=intervals.size();
        sort(intervals.begin(),intervals.end(),cmp);//按右端点排序
        int cnt=1,end=intervals[0][1];//第一个默认为不重叠区间
        for(int i=1;i<n;i++){//从第二个开始，从左往右找到不重叠区间
            if(end<=intervals[i][0]){
                cnt++;//记录不重叠区间
                end=intervals[i][1];
            } 
        }
        return n-cnt;
    }
};
```

3）[[763. 划分字母区间](https://leetcode-cn.com/problems/partition-labels/)——中等]（方法一，统计区间，融合区间计算长度。）

```c++
class Solution {
public:
    static bool cmp(const vector<int> &a,const vector<int> &b){
        return a[0]<b[0];
    }
    vector<int> partitionLabels(string s) {
        vector<int>ans;
        vector<vector<int>>qujian;
        int n=s.size();
        //统计字符串中每位字母的起止位置
        unordered_map<char,pair<int,int>>mp;
        for(int i=0;i<n;i++){
            char str=s[i];
            if(mp.find(str)==mp.end()){
                mp[str].first=i;
                mp[str].second=i;
            }
            else{
                mp[str].second=i;
            }
        }
        for(auto it:mp){
            qujian.push_back({it.second.first,it.second.second});
        }
        //按第一位排序
        sort(qujian.begin(),qujian.end(),cmp);
        //融合区间，统计每个区间长度
        int st=qujian[0][0],end=qujian[0][1];
        int m=qujian.size();
        for(int i=1;i<m;i++){
            if(qujian[i][0]<end){
                end=max(end,qujian[i][1]);
                st=min(st,qujian[i][0]);
            }
            else{
                ans.push_back(end-st+1);
                st=qujian[i][0];
                end=qujian[i][1];
            }
        }
        ans.push_back(end-st+1);
        return ans;
    }
};
```

4）[[56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)——中等]（方法一，按左端点排序，合并区间更新st、end。）

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        int n=intervals.size();
        sort(intervals.begin(),intervals.end());//按第一位从小到大
        int st=intervals[0][0],end=intervals[0][1];
        vector<vector<int>>ans;
        for(int i=1;i<n;i++){
            if(intervals[i][0]<=end){//融合区间，更新起止位置
                st=min(st,intervals[i][0]);
                end=max(end,intervals[i][1]);
            }
            else{//遇到非重叠区间，存入答案，更新起止位置
                ans.push_back({st,end});
                st=intervals[i][0];
                end=intervals[i][1];
            }
        }
        ans.push_back({st,end});//存入最后一个
        return ans;
    }
};
```

## 5.困难贪心问题

### 练习

1）[[738. 单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/)——中等]（方法一，从后往前遍历，若前一位大于后一位，将前一位减减，记录当前位最后把flag后全改为9。）

```c++
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        string num=to_string(n);
        int m=num.size();
        int flag=m;
        for(int i=m-1;i>0;i--){
            if(num[i-1]>num[i]){//前一位大于后一位
                num[i-1]--;
                flag=i;
            }
        }
        for(int i=flag;i<m;i++){
            num[i]='9';
        }
        return stoi(num);
    }
};
```

2）[[714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)——中等]（方法一，记录最小进价，若无收益则跳过，有收益则卖出，并更新进价，记录有收益区间的利润，卖出后进价减去费率相当于提高了利润，若之后有大于当前价格的再次卖出，把第一次费率抵消。）

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n=prices.size(),ans=0;
        int minpri=prices[0];//最小进价
        for(int i=1;i<n;i++){
            if(prices[i]<minpri){
                minpri=prices[i];//买入
            }
            if(prices[i]<=minpri+fee)   continue;//不挣钱，跳过
            if(prices[i]>minpri+fee){//可能卖出
                ans+=prices[i]-minpri-fee;//现在挣的钱
                minpri=prices[i]-fee;//更新进价，如果当前不是最后收益日期的话，当前买入价格减去费率相当于提高了利润
            }//相当于在最后一个收益日期卖出
        }
        return ans;
    }
};
```

3）[[968. 监控二叉树](https://leetcode-cn.com/problems/binary-tree-cameras/)——困难]（方法一，后序遍历，3种状态：未覆盖、有摄像头、被覆盖，四种情况：1.左右被覆盖则当前没覆盖；2.左右有一个没覆盖则当前加摄像头；3.左右有一个有摄像头则当前被覆盖；4.根节点没覆盖加摄像头。）

```c++
class Solution {
public:
    int ans=0;
    int lastorder(TreeNode* root){//三种状态：1.为0时未覆盖；2.为1时有摄像头；3.为2时覆盖
        if(!root)   return 2;//空结点存覆盖
        int left=lastorder(root->left);//左子树
        int right=lastorder(root->right);//右子树
        if(left==2&&right==2){//情况1:：左右子树均覆盖，父节点未覆盖
            return 0;
        }
        if(left==0||right==0){//情况2：左右子树有一个未覆盖，父节点为摄像头
            ans++;
            return 1;
        }
        if(left==1||right==1){//情况3：左右子树有摄像头，父节点被覆盖
            return 2;
        }
        return -1;
    }
    int minCameraCover(TreeNode* root) {
        //情况4：父节点没被覆盖，摄像头+1
        if(lastorder(root)==0)  ans++;
        return ans;
    }
};
```

# 九、动态规划

> 1.确定dp数组（dp table）以及下标的含义
>
> 2.确定递推公式
>
> 3.dp数组如何初始化
>
> 4.确定遍历顺序
>
> 5.举例推导dp数组

## 1.基础练习

### 练习

1）[[746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)——简单]（方法一，动态规划，花费cost可以跳1格或2格，每次取前一个或前两个的最小值+当前cost，最后返回前一个或前两个中最小的，因为最后一步不花费。）

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n=cost.size();
        vector<int>dp(n);
        dp[0]=cost[0];
        dp[1]=cost[1];
        for(int i=2;i<n;i++){
            dp[i]=min(dp[i-2],dp[i-1])+cost[i];
            //cout<<dp[i]<<endl;
        }
        return min(dp[n-1],dp[n-2]);//最后一步不花费
    }
};
```

2）[[62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)——中等]（方法一，动态规划，定义dp[i] [j]表示到达ij位置共有几条路线，dp[i] [j] ==ij位置左和上的路线和。）

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>>dp(m,vector<int>(n,1));
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j]=dp[i-1][j]+dp[i][j-1];//为左和上路线数之和
            }
        }
        return dp[m-1][n-1];
    }
};
```

3）[[63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)——中等]（方法一，动态规划，障碍物在起点时直接返回0，预处理二维数组将障碍物位置变为0，空白位置变为1，然后若上或左有一个不为0该位仍为1，否则改为0，然后再从[1,1]处开始遍历，遇0跳过。）

```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m=obstacleGrid.size(),n=obstacleGrid[0].size();
        if(obstacleGrid[0][0]==1)   return 0;//起点为障碍物直接返回0
        for(int i=0;i<m;i++){//障碍物改为0，空白改为1
            for(int j=0;j<n;j++){
                if(obstacleGrid[i][j]==0)   obstacleGrid[i][j]=1;
                else    obstacleGrid[i][j]=0;
            }
        }
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(obstacleGrid[i][j]==0)   continue;//遇0跳过
                if(i==0&&j==0)  continue;//起点跳过
                if((i-1>=0&&obstacleGrid[i-1][j]!=0)||(j-1>=0&&obstacleGrid[i][j-1]!=0)){
                    obstacleGrid[i][j]=1;//若上或左有不为0的该位保持
                }
                else    obstacleGrid[i][j]=0;//否则改为0
            }
        }
        for(int i=1;i<m;i++){//遍历，ij位置的路线为上和左路线之和
            for(int j=1;j<n;j++){
                if(obstacleGrid[i][j]==0)   continue;
                obstacleGrid[i][j]=obstacleGrid[i-1][j]+obstacleGrid[i][j-1];
            }
        }
        return obstacleGrid[m-1][n-1];
    }
};
```

4）[[343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)——中等]（方法一，动态规划，dp[i]表示数字i拆分后的最大乘积。）

```c++
class Solution {
public:
    int integerBreak(int n) {
        vector<int>dp(n+1);//数字i拆分后的最大乘积
        dp[2]=1;//初始化
        for(int i=3;i<=n;i++){
            for(int j=1;j<i-1;j++){//j从1开始到i-1结束
                dp[i]=max(dp[i],max((i-j)*j,dp[i-j]*j));//(i-j)*j表示拆成2份的乘积，dp[i-j]*j表示拆成多份的乘积
            }
        }
        return dp[n];
    }
};
```

5）[[96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)——中等]（方法一，动态规划，以i为根节点的数量为以j为根节点的左子树数量*以j为根节点的右子树数量，j从1开始到i。方法二，卡特兰数。）

```c++
//动态规划
class Solution {
public:
    int numTrees(int n) {
        vector<int>dp(n+1);
        dp[0]=1;
        for(int i=1;i<=n;i++){
            for(int j=1;j<=i;j++){
                dp[i]+=dp[j-1]*dp[i-j];//j-1为以j为头结点的左子树数量，i-j为以j为头结点右子树的数量
            }
        }
        return dp[n];
    }
};
//数学，计算卡特兰数C(n+1)=C(n)*2*(2*n+1)/(n+2),n从0开始
class Solution {
public:
    int numTrees(int n) {
        if(n==1)    return 1;
        int i;
        long long ans=1;
        for(i=0;i<n;i++){
            ans=ans*2*(2*i+1)/(i+2);
        }
        return (int)ans;
    }
};
```

## 2.背包问题

![image-20210818151332655](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210818151332655.png)

### 1）01背包问题

> 1.确定dp数组的定义：
>
> ​			在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。

> 2.一维dp数组的递推公式

```c++
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

> 3.一维dp数组如何初始化：
>
> ​			如果物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。

> 4.一维dp数组遍历顺序：

代码如下：

```c++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

#### 练习（01背包）

1）[[416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)——中等]（方法一，01背包，若能分为总和/2大小的子集则返回true，定义dp为大小为i的背包最多装多少东西。）

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum=0;
        for(auto x:nums)    sum+=x;
        if(sum%2==1)    return false;
        sum/=2;
        vector<int>dp(10001,0);//初始化背包，i容量的背包最多装多少
        for(int i=0;i<nums.size();i++){
            for(int j=sum;j>=nums[i];j--){
                //dp[j]表示当前物品不背，dp[j-nums[i]]+nums[i]表示背上当前物品，前一个不背当前物品的背包最多背的重量+当前物品重量
                dp[j]=max(dp[j],dp[j-nums[i]]+nums[i]);//第i个物品不背背或背
            }
        }
        return dp[sum]==sum;
    }
};
```

2）[[1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)——中等]（方法一，01背包，划分为重量尽可能相同的两堆，最后最大容量的2倍-总和。）

```c++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        //分解为尽量重量相同的两堆
        int n=stones.size(),sum=0,flag=0,target;
        for(auto x:stones)  sum+=x;
        target=sum/2;
        vector<int>dp(target+1,0);
        for(int i=0;i<n;i++){
            for(int j=target;j>=stones[i];j--){
                dp[j]=max(dp[j],dp[j-stones[i]]+stones[i]);
            }
        }
        flag=dp.back();
        return abs(2*flag-sum);
    }
};
```

> 求装满x背包有多少种方法使用：dp[j] += dp[j - nums[i]];
>
> j大小的背包装满需要当前方法数+装满j-nums[i]大小的背包方法数

3）[[494. 目标和](https://leetcode-cn.com/problems/target-sum/)——中等]（方法一，01背包，数组中为+号的总和为x，为-号的总和为sum-x，使x-(sum-x)==target，得到x为(target+sum)/2，转换为01背包问题，装满x的背包有几种情况。）

```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int n=nums.size(),sum=0;
        for(auto x:nums)    sum+=x;
        if(target>sum)  return 0;
        if((target+sum)%2==1)   return 0;//若为奇数则没有方法组成target,如sum=5，target=2
        int bigsize=(target+sum)/2;
        if(bigsize<0)   return 0;
        vector<int>dp(bigsize+1);
        dp[0]=1;//初始化
        for(int i=0;i<n;i++){
            for(int j=bigsize;j>=nums[i];j--){
                dp[j]+=dp[j-nums[i]];//j大小的背包由j-nums[i]大小的背包组成
            }
        }
        return dp[bigsize];
    }
};
```

4）[[474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)——中等]（方法一，两个维度的01背包，表示i个0j个1的最长子集长度。）

```c++
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>>dp(m+1,vector<int>(n+1));//存i个0j个1的子集长度
        for(auto s:strs){
            int zeros=0,ones=0;
            for(auto ch:s){
                if(ch=='0') zeros++;
                else    ones++;
            }
            //2个维度的01背包
            for(int i=m;i>=zeros;i--){//从后往前遍历背包
                for(int j=n;j>=ones;j--){
                    dp[i][j]=max(dp[i][j],dp[i-zeros][j-ones]+1);//取前一个状态最大值
                }
            }
        }
        return dp[m][n];
    }
};
```

### 2）完全背包

>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。
>
>**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。
>
>**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。
>
>**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

```c++
//基本先遍历物品再遍历背包
// 如果求组合数就是外层for循环遍历物品，内层for遍历背包。组合不要求顺序，（1,5），（5，1）为一个组合
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j < bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

```c++
// 如果求排列数就是外层for遍历背包，内层for循环遍历物品。排列要求顺序，（1,5），（5,1）为两个排列
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

#### 练习（完全背包）

1）[[518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)——中等]（方法一，完全背包，dp[i]存凑满i的方法数。）

```c++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int n=coins.size();
        vector<int>dp(amount+1);//存凑满i的方法数
        dp[0]=1;//初始化为1
        for(int i=0;i<n;i++){
            for(int j=coins[i];j<=amount;j++){
                dp[j]+=dp[j-coins[i]];//加上凑满j-coins[i]的方法数
            }
        }
        return dp[amount];
    }
};
```

2）[[377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)——中等]（方法一，完全背包，找到凑满target背包的全部排列，外层遍历背包容量，内层遍历物品。）

```c++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        int n=nums.size();
        vector<int>dp(target+1);//存装满dp[i]容量的排列数
        dp[0]=1;
        for(int j=1;j<=target;j++){
            for(int i=0;i<n;i++){
                if(j-nums[i]>=0&&dp[j]<INT_MAX-dp[j-nums[i]]){//数组下标大于等于0，防止出现溢出情况
                    dp[j]+=dp[j-nums[i]];
                }
            }
        }
        return dp[target];
    }
};
```

3）[[70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)——简单]（方法一，动态规划。若改为：每次可以爬1-m阶，爬到n阶的方法，完全背包，外层遍历背包容量，内层遍历物品。）

```c++
//基础
class Solution {
public:
    int climbStairs(int n) {
        if(n==1)    return 1;
        vector<int>dp(n+1);
        dp[0]=0;
        dp[1]=1;
        dp[2]=2;
        for(int i=3;i<=n;i++){
            dp[i]=dp[i-2]+dp[i-1];
        }
        return dp[n];
    }
};
//进阶：每次爬1-m阶
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) { // 遍历背包
            for (int j = 1; j <= m; j++) { // 遍历物品
                if (i - j >= 0) dp[i] += dp[i - j];//爬到当前i的方法数为前面所有爬到i-j的方法之和
            }
        }
        return dp[n];
    }
};
```

4）[[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)——中等]（方法一，完全背包，找到凑满零钱j的最小硬币数量，外层遍历背包容量，内层遍历硬币面值。）

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n=coins.size();
        vector<int>dp(amount+1,INT_MAX-1);//要取最小值，初始设为极值
        dp[0]=0;//初始值
        for(int j=1;j<=amount;j++){//先遍历背包容量
            for(int i=0;i<n;i++){//再遍历每个硬币面值
                if(j-coins[i]>=0)
                    dp[j]=min(dp[j-coins[i]]+1,dp[j]);//每次取凑满当前容量的硬币数量和凑满j-每个硬币的背包容量的硬币数量+1的最小值
            }
        }
        return dp[amount]!=INT_MAX-1?dp[amount]:-1;//若答案为最大值说明凑不满返回-1
    }
};
```

5）[[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)——中等]（方法一，完全背包，凑满背包的最小完全平方数的数量，外层遍历背包，内层遍历小于等于n的完全平方数。）

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int>dp(n+1,INT_MAX-1);//初始化为极值
        dp[0]=0;
        for(int j=1;j<=n;j++){//遍历背包
            for(int i=1;i*i<=j;i++){//遍历完全平方数
				dp[j]=min(dp[j-i*i]+1,dp[j]);//取凑满当前容量的数量和凑满j-i*i容量的数量之间的最小值
            }
        }
        return dp[n];
    }
};
```

6）[[139. 单词拆分](https://leetcode-cn.com/problems/word-break/)——中等]（方法一，完全背包，设定dp[i]为长度为i的字符串是否可以被分割，每次截取背包容量长度的子字符串查询是否在wordDict中，若存在并且起始点之前的字符串可以被分割，则当前长度也可以被分割。）

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        int n=s.size();
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());//去重
        vector<bool>dp(n+1,false);
        dp[0]=true;//初始为true
        for(int j=1;j<=n;j++){//遍历背包
            for(int i=0;i<j;i++){//遍历起始位置
                string word=s.substr(i,j-i);//从i开始截取字符串，长度为j-i
                if(wordSet.find(word)!=wordSet.end()&&dp[i]){//如果在字符串列表中找到截取的字符串并且长度为i的字符串可以被分割
                    dp[j]=true;
                }
            }
        }
        return dp[n];
    }
};
```

### 3）多重背包

> 有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。
>
> 可以转换为01背包问题

![image-20210830165946670](C:\Users\Jiao1\AppData\Roaming\Typora\typora-user-images\image-20210830165946670.png)

```c++
//时间复杂度：O(m * n * k) m：物品种类个数，n背包容量，k单类物品数量
void test_multi_pack() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    vector<int> nums = {2, 3, 2};
    int bagWeight = 10;
    for (int i = 0; i < nums.size(); i++) {
        while (nums[i] > 1) { // nums[i]保留到1，把其他物品都展开
            weight.push_back(weight[i]);
            value.push_back(value[i]);
            nums[i]--;
        }
    }

    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
        for (int j = 0; j <= bagWeight; j++) {
            cout << dp[j] << " ";
        }
        cout << endl;
    }
    cout << dp[bagWeight] << endl;

}
int main() {
    test_multi_pack();
}
```



```c++
//时间复杂度：O(m * n * k) m：物品种类个数，n背包容量，k单类物品数量
void test_multi_pack() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    vector<int> nums = {2, 3, 2};
    int bagWeight = 10;
    vector<int> dp(bagWeight + 1, 0);


    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            // 以上为01背包，然后加一个遍历个数
            for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) { // 遍历个数
                dp[j] = max(dp[j], dp[j - k * weight[i]] + k * value[i]);
            }
        }
        // 打印一下dp数组
        for (int j = 0; j <= bagWeight; j++) {
            cout << dp[j] << " ";
        }
        cout << endl;
    }
    cout << dp[bagWeight] << endl;
}
int main() {
    test_multi_pack();
}
```

### 4）打家劫舍系列问题

1）[[198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)——中等]（方法一，动态规划，二维数组表示第i间屋子偷或不偷的最大值。）

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n=nums.size(),ans=0;
        vector<vector<int>>dp(n,vector<int>(2));
        dp[0][0]=0;//不偷
        dp[0][1]=nums[0];//偷
        ans=max(dp[0][0],dp[0][1]);
        for(int i=1;i<n;i++){
            dp[i][0]=max(dp[i-1][1],dp[i-1][0]);//当前不偷，取前一个偷或不偷的最大值
            dp[i][1]=dp[i-1][0]+nums[i];//当前偷，前一个不偷加上当前
            ans=max(ans,max(dp[i][0],dp[i][1]));//每次取最大
        }
        return ans;
    }
};
```

2）[[213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)——中等]（方法一，动态规划，数组成环，可以考虑去掉头或者去掉尾之间打家劫舍的最大值。）

```c++
class Solution {
public:
    int robda(vector<int>& nums,int st,int end){//单纯打家劫舍问题
        if(st==end) return nums[end];
        vector<int>dp(nums.size());
        dp[st]=nums[st];
        dp[st+1]=max(nums[st],nums[st+1]);
        for(int i=st+2;i<=end;i++){
            dp[i]=max(dp[i-2]+nums[i],dp[i-1]);
        }
        return dp[end];
    }
    int rob(vector<int>& nums) {
        int n=nums.size();
        if(n==0)    return 0;
        if(n==1)    return nums[0];
        int res1=robda(nums,1,n-1);//去掉头，偷最后一间不偷第一间
        int res2=robda(nums,0,n-2);//去掉尾，偷第一间不偷最后一间
        return max(res1,res2);
    }
};
```

3）[[337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)——中等]（方法一，树形dp，需要根据左右子树的结果来判断根节点的运算，所以使用后序遍历，用2位数组表示不偷当前和偷当前的最大值。）

```c++
class Solution {
public:
    vector<int> robtree(TreeNode* root){
        //返回一个2位数组，0位表示不偷的最大值，1位表示偷了的最大值
        if(root==nullptr)   return vector<int>{0, 0};
        //后序遍历
        vector<int>tleft=robtree(root->left);
        vector<int>tright=robtree(root->right);
        //不偷当前
        int val1=max(tleft[0],tleft[1])+max(tright[0],tright[1]);//前一个左右子树偷或不偷的最大值
        //偷当前
        int val2=root->val+tleft[0]+tright[0];//当前值+前一个左右子树不偷的最大值
        return  {val1,val2};
    }
    int rob(TreeNode* root) {
        vector<int>res=robtree(root);
        return max(res[0],res[1]);
    }
};
```

### 5）买卖股票系列问题

1）[[121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)——简单]（方法一，每次收益最大为当前股价减去之前最低价。方法二，动态规划，二维数组表示第i天是否持有股票，不持有则取当前卖出收益和前一天不持有最大值，持有则取前一天持有和买入当前股票的最大值。）

```c++
//方法一，贪心
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int i,j,ans=0,m=10001;
        for(i=0;i<prices.size();i++){
            ans=max(ans,prices[i]-m);//假如第i天卖股票，最大收益为前i天的最低点
            m=min(m,prices[i]);//选出前i天最低价
        }
        return ans;
    }
};
//方法二，动态规划
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n=prices.size();
        vector<vector<int>>dp(n,vector<int>(2));//0位表示第i天持有股票，1位表示第i天不持有股票
        dp[0][0]=-prices[0];//持有股票
        dp[0][1]=0;//不持有股票
        for(int i=1;i<n;i++){
            //第i天持有股票
            dp[i][0]=max(dp[i-1][0],-prices[i]);//取前一天持有股票的现金和买入当前股票的最大值
            //第i天不持有股票
            dp[i][1]=max(dp[i-1][1],prices[i]+dp[i-1][0]);//取前一天不持有股票的现金和前一天持有股票+当前卖出的收益的最大值

        }
        return dp[n-1][1];
    }
};
```

